(function() {
    'use strict';

// ========== INJECT CART HTML STRUCTURE ==========
function injectCartHTML() {
    const cartHTML = `
        <div class="cart-container">
            <div class="left-section">
                <i class="fa fa-shopping-cart" id="cartQty" data-count="0"></i>
                <span class="cart-total">0.00</span>
            </div>
            <div class="right-section">
                <button id="cart-toggle-btn">
                    <span class="toggle-btn-txt">TEMPAH SEKARANG</span>
                    <i class="fa fa-times"></i>
                </button>
            </div>
        </div>
        <div id="form-overlay"></div>
    `;

    // Inject at the end of body
    document.body.insertAdjacentHTML('beforeend', cartHTML);
}

// ========== UTILITY FUNCTIONS ==========
/**
 * Get price for a specific product (unit price √ó quantity)
 * @param {number} productId - The product ID to check
 * @returns {number} - Total price of the product (price √ó qty)
 */
function getProductPrice(productId) {
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (!productRow) {
        return 0;
    }
    
    // Get subtotal price from table
    const subtotalCell = productRow.querySelector('.subtotal-price');
    
    if (subtotalCell) {
        const priceText = subtotalCell.textContent.trim();
        return parseFloat(priceText) || 0;
    }
    
    return 0;
}

/**
 * Get total price from cart
 * @returns {number} - Total price in cart
 */
function getTotalPrice() {
    const totalPriceElement = document.querySelector('.total-price');
    
    if (totalPriceElement) {
        const priceText = totalPriceElement.textContent.trim();
        return parseFloat(priceText) || 0;
    }
    
    return 0;
}

/**
 * Setup monitoring for price changes
 */
function setupPriceMonitoring() {
    // Monitor subtotal price elements
    const subtotalElements = document.querySelectorAll('.subtotal-price');
    
    subtotalElements.forEach(element => {
        const observer = new MutationObserver(() => {
            updateAllBumpVisibility();
        });
        
        observer.observe(element, {
            childList: true,
            characterData: true,
            subtree: true
        });
    });
    
    // Monitor total price element
    const totalPriceElement = document.querySelector('.total-price');
    
    if (totalPriceElement) {
        const observer = new MutationObserver(() => {
            updateAllBumpVisibility();
        });
        
        observer.observe(totalPriceElement, {
            childList: true,
            characterData: true,
            subtree: true
        });
    }
    
    // Monitor total amount element (alternative)
    const totalAmountElement = document.querySelector('.total-amount');
    
    if (totalAmountElement) {
        const observer = new MutationObserver(() => {
            updateAllBumpVisibility();
        });
        
        observer.observe(totalAmountElement, {
            childList: true,
            characterData: true,
            subtree: true
        });
    }
    
    if (window.cartConfig.debugMode) {
        console.log('üí∞ Price monitoring setup complete');
    }
}

/**
 * Check bump conditions with multiple conditions & products support
 * @param {Object} bumpConfig - The order bump configuration
 * @returns {Object} - Detailed status of conditions
 */
function checkBumpConditionsDetailed(bumpConfig) {
    const result = {
        met: true,
        hasStarted: false,
        remainingTotal: 0,
        remainingProduct: 0,
        remainingTotalPrice: 0,
        remainingProductPrice: 0,
        productDetails: [],
        conditionResults: [] 
    };

    if (!bumpConfig.conditions) {
        return result;
    }

    // ========== NEW: Multiple Conditions Support ==========
    if (bumpConfig.conditions.multipleConditions && Array.isArray(bumpConfig.conditions.multipleConditions)) {
        const combineLogic = bumpConfig.conditions.combineLogic || 'all';
        
        // Check each condition
        const conditionResults = bumpConfig.conditions.multipleConditions.map((condition, index) => {
            const condResult = checkSingleCondition(condition);
            
            if (condResult.hasStarted) {
                result.hasStarted = true;
            }
            
            return {
                index,
                type: condition.type,
                met: condResult.met,
                hasStarted: condResult.hasStarted,
                details: condResult
            };
        });
        
        result.conditionResults = conditionResults;
        
        // Apply combine logic
        if (combineLogic === 'all') {
            // ALL conditions must be met (AND)
            const allMet = conditionResults.every(c => c.met);
            result.met = allMet;
            
            // Collect all remaining values for notification
            conditionResults.forEach(c => {
                if (!c.met) {
                    if (c.details.remainingTotal > 0) {
                        result.remainingTotal = Math.max(result.remainingTotal, c.details.remainingTotal);
                    }
                    if (c.details.remainingProduct > 0) {
                        result.remainingProduct = Math.max(result.remainingProduct, c.details.remainingProduct);
                    }
                    if (c.details.remainingTotalPrice > 0) {
                        result.remainingTotalPrice = Math.max(result.remainingTotalPrice, c.details.remainingTotalPrice);
                    }
                    if (c.details.remainingProductPrice > 0) {
                        result.remainingProductPrice = Math.max(result.remainingProductPrice, c.details.remainingProductPrice);
                    }
                    if (c.details.productDetails && c.details.productDetails.length > 0) {
                        result.productDetails.push(...c.details.productDetails);
                    }
                }
            });
        } else if (combineLogic === 'any') {
            // ANY condition is met (OR)
            const anyMet = conditionResults.some(c => c.met);
            result.met = anyMet;
            
            if (!anyMet) {
                // Get minimum remaining values from unmet conditions
                const unmetConditions = conditionResults.filter(c => !c.met);
                
                const totalValues = unmetConditions.map(c => c.details.remainingTotal).filter(v => v > 0);
                if (totalValues.length > 0) {
                    result.remainingTotal = Math.min(...totalValues);
                }
                
                const priceValues = unmetConditions.map(c => c.details.remainingTotalPrice).filter(v => v > 0);
                if (priceValues.length > 0) {
                    result.remainingTotalPrice = Math.min(...priceValues);
                }
                
                const productValues = unmetConditions.map(c => c.details.remainingProduct).filter(v => v > 0);
                if (productValues.length > 0) {
                    result.remainingProduct = Math.min(...productValues);
                }
                
                const productPriceValues = unmetConditions.map(c => c.details.remainingProductPrice).filter(v => v > 0);
                if (productPriceValues.length > 0) {
                    result.remainingProductPrice = Math.min(...productPriceValues);
                }
            }
        }
        
        return result;
    }

    // ========== BACKWARD COMPATIBILITY: Old Single Condition Format ==========
    if (!bumpConfig.conditions.type) {
        return result;
    }

    const singleResult = checkSingleCondition(bumpConfig.conditions);
    return singleResult;
}

/**
 * Check a single condition (extracted for reusability)
 * @param {Object} condition - Single condition object
 * @returns {Object} - Result for this condition
 */
function checkSingleCondition(condition) {
    const result = {
        met: true,
        hasStarted: false,
        remainingTotal: 0,
        remainingProduct: 0,
        remainingTotalPrice: 0,
        remainingProductPrice: 0,
        productDetails: []
    };

    const condType = condition.type;
    const productCombineLogic = condition.productCombineLogic || condition.combineLogic || 'all';

    // ========== QUANTITY-BASED CONDITIONS ==========
    
    if (condType === 'total') {
        const currentTotal = getTotalQuantity();
        const requiredTotal = condition.minTotalQuantity || 1;
        
        if (currentTotal > 0) {
            result.hasStarted = true;
        }

        if (currentTotal < requiredTotal) {
            result.met = false;
            result.remainingTotal = requiredTotal - currentTotal;
        }
    }

    if (condType === 'product') {
        // Multiple products support
        if (condition.requiredProducts && Array.isArray(condition.requiredProducts)) {
            const productResults = condition.requiredProducts.map(reqProduct => {
                const currentQty = getProductQuantity(reqProduct.id);
                const requiredQty = reqProduct.minQuantity || 1;
                const isMet = currentQty >= requiredQty;
                
                if (currentQty > 0) {
                    result.hasStarted = true;
                }
                
                return {
                    id: reqProduct.id,
                    currentQty,
                    requiredQty,
                    remaining: Math.max(0, requiredQty - currentQty),
                    met: isMet
                };
            });
            
            result.productDetails = productResults;
            
            if (productCombineLogic === 'all') {
                const allMet = productResults.every(p => p.met);
                if (!allMet) {
                    result.met = false;
                    result.remainingProduct = Math.max(...productResults.map(p => p.remaining));
                }
            } else if (productCombineLogic === 'any') {
                const anyMet = productResults.some(p => p.met);
                if (!anyMet) {
                    result.met = false;
                    result.remainingProduct = Math.min(...productResults.filter(p => p.remaining > 0).map(p => p.remaining));
                }
            }
        }
        // Single product (backward compatibility)
        else if (condition.requiredProduct) {
            const reqProduct = condition.requiredProduct;
            const currentQty = getProductQuantity(reqProduct.id);
            const requiredQty = reqProduct.minQuantity || 1;

            if (currentQty > 0) {
                result.hasStarted = true;
            }

            if (currentQty < requiredQty) {
                result.met = false;
                result.remainingProduct = requiredQty - currentQty;
            }
            
            result.productDetails = [{
                id: reqProduct.id,
                currentQty,
                requiredQty,
                remaining: Math.max(0, requiredQty - currentQty),
                met: currentQty >= requiredQty
            }];
        }
    }

    // ========== PRICE-BASED CONDITIONS ==========
    
    if (condType === 'price-total') {
        const currentTotalPrice = getTotalPrice();
        const requiredTotalPrice = condition.minTotalPrice || 0;
        
        if (currentTotalPrice > 0) {
            result.hasStarted = true;
        }

        if (currentTotalPrice < requiredTotalPrice) {
            result.met = false;
            result.remainingTotalPrice = requiredTotalPrice - currentTotalPrice;
        }
    }

    if (condType === 'price-product') {
        // Multiple products support
        if (condition.requiredProducts && Array.isArray(condition.requiredProducts)) {
            const productResults = condition.requiredProducts.map(reqProduct => {
                const currentPrice = getProductPrice(reqProduct.id);
                const requiredPrice = reqProduct.minPrice || 0;
                const isMet = currentPrice >= requiredPrice;
                
                if (currentPrice > 0) {
                    result.hasStarted = true;
                }
                
                return {
                    id: reqProduct.id,
                    currentPrice,
                    requiredPrice,
                    remaining: Math.max(0, requiredPrice - currentPrice),
                    met: isMet
                };
            });
            
            result.productDetails = productResults;
            
            if (productCombineLogic === 'all') {
                const allMet = productResults.every(p => p.met);
                if (!allMet) {
                    result.met = false;
                    result.remainingProductPrice = Math.max(...productResults.map(p => p.remaining));
                }
            } else if (productCombineLogic === 'any') {
                const anyMet = productResults.some(p => p.met);
                if (!anyMet) {
                    result.met = false;
                    result.remainingProductPrice = Math.min(...productResults.filter(p => p.remaining > 0).map(p => p.remaining));
                }
            }
        }
        // Single product (backward compatibility)
        else if (condition.requiredProduct) {
            const reqProduct = condition.requiredProduct;
            const currentProductPrice = getProductPrice(reqProduct.id);
            const requiredProductPrice = reqProduct.minPrice || 0;

            if (currentProductPrice > 0) {
                result.hasStarted = true;
            }

            if (currentProductPrice < requiredProductPrice) {
                result.met = false;
                result.remainingProductPrice = requiredProductPrice - currentProductPrice;
            }
            
            result.productDetails = [{
                id: reqProduct.id,
                currentPrice: currentProductPrice,
                requiredPrice: requiredProductPrice,
                remaining: Math.max(0, requiredProductPrice - currentProductPrice),
                met: currentProductPrice >= requiredProductPrice
            }];
        }
    }

    return result;
}

/**
 * ========================================
 * STANDARDIZED PLACEHOLDER DEFINITIONS
 * ========================================
 */
const NOTIFICATION_PLACEHOLDERS = {
    // Bump info
    bumpName: '{bumpName}',
    
    // Product info
    productName: '{productName}',
    productQuantity: '{productQuantity}',
    productPrice: '{productPrice}',
    
    // Current values in cart
    currentProductQuantity: '{currentProductQuantity}',
    currentProductPrice: '{currentProductPrice}',
    
    // Remaining requirements (STANDARDIZED - Context-Aware)
    remainingTotal: '{remainingTotal}',                 // Total cart quantity
    remainingProduct: '{remainingProduct}',             // Product quantity (context-aware)
    remainingTotalPrice: '{remainingTotalPrice}',       // Total cart price
    remainingProductPrice: '{remainingProductPrice}',   // Product price (context-aware)
    
    // Total requirements
    totalQuantity: '{totalQuantity}',
    totalPrice: '{totalPrice}',
    
    // Multiple conditions
    conditions: '{conditions}',
};

function getPlaceholderValue(placeholder, bumpConfig, conditionStatus) {
    const key = placeholder.replace(/[{}]/g, '');
    
    switch(key) {
        // Bump info
        case 'bumpName':
            return `<strong>${bumpConfig.productName || 'order bump'}</strong>`;
        
        // Product info
        case 'productName':
            return getProductNameFormatted(bumpConfig, conditionStatus);
        
        case 'productQuantity':
            return `<strong>${conditionStatus.productDetails?.[0]?.requiredQty || 1}</strong>`;
        
        case 'productPrice':
            return `<strong>${formatPrice(conditionStatus.productDetails?.[0]?.requiredPrice || 0)}</strong>`;
        
        // Current values
        case 'currentProductQuantity':
            return `<strong>${conditionStatus.productDetails?.[0]?.currentQty || 0}</strong>`;
        
        case 'currentProductPrice':
            return `<strong>${formatPrice(conditionStatus.productDetails?.[0]?.currentPrice || 0)}</strong>`;
        
        // ===== STANDARDIZED: Context-Aware Placeholders =====
        
        // Remaining values - QUANTITY (context-aware)
        case 'remainingTotal':
            return `<strong>${conditionStatus.remainingTotal || 0}</strong>`;
        
        case 'remainingProduct':
            // üî• CONTEXT-AWARE: Check if we're in list item context
            if (conditionStatus.remaining !== undefined) {
                // List item context - return specific item's remaining
                return `<strong>${conditionStatus.remaining}</strong>`;
            }
            // Global context - return summary/max remaining
            return `<strong>${conditionStatus.remainingProduct || 0}</strong>`;
        
        // Remaining values - PRICE (context-aware)
        case 'remainingTotalPrice':
            return `<strong>${formatPrice(conditionStatus.remainingTotalPrice || 0)}</strong>`;
        
        case 'remainingProductPrice':
            // üî• CONTEXT-AWARE: Check if we're in list item context
            if (conditionStatus.remaining !== undefined) {
                // List item context - return specific item's remaining price
                return `<strong>${formatPrice(conditionStatus.remaining)}</strong>`;
            }
            // Global context - return summary/max remaining price
            return `<strong>${formatPrice(conditionStatus.remainingProductPrice || 0)}</strong>`;
        
        // Total requirements
        case 'totalQuantity':
            return `<strong>${getTotalQuantityRequirement(bumpConfig)}</strong>`;
        
        case 'totalPrice':
            return `<strong>${formatPrice(getTotalPriceRequirement(bumpConfig))}</strong>`;
        
        // Multiple conditions
        case 'conditions':
            return '{conditions}';
        
        default:
            console.warn(`‚ö†Ô∏è Unknown placeholder: ${placeholder}`);
            return placeholder;
    }
}

function getProductNameFormatted(bumpConfig, conditionStatus) {
    let productName = 'produk';
    
    // ‚úÖ CHECK: Internal key first (injected by list context)
    if (conditionStatus._productName) {
        return `<strong>${conditionStatus._productName}</strong>`;
    }
    
    // Multiple products (global context)
    if (conditionStatus.productDetails && conditionStatus.productDetails.length > 0) {
        const names = conditionStatus.productDetails.map(detail => {
            const productData = getProductDataById(detail.id);
            return productData?.name || `Produk ${detail.id}`;
        });
        
        if (names.length === 1) {
            productName = names[0];
        } else if (names.length === 2) {
            productName = names.join(' & ');
        } else {
            productName = names.slice(0, -1).join(', ') + ' & ' + names[names.length - 1];
        }
    }
    // Single product from condition
    else if (bumpConfig.conditions.requiredProduct) {
        const productData = getProductDataById(bumpConfig.conditions.requiredProduct.id);
        productName = productData?.name || `Produk ${bumpConfig.conditions.requiredProduct.id}`;
    }
    
    return `<strong>${productName}</strong>`;
}

/**
 * Get total quantity requirement from config
 */
function getTotalQuantityRequirement(bumpConfig) {
    if (bumpConfig.conditions.multipleConditions) {
        const totalCondition = bumpConfig.conditions.multipleConditions.find(c => 
            c.type === 'total' && c.minTotalQuantity
        );
        return totalCondition?.minTotalQuantity || 0;
    }
    return bumpConfig.conditions.minTotalQuantity || 0;
}

/**
 * Get total price requirement from config
 */
function getTotalPriceRequirement(bumpConfig) {
    if (bumpConfig.conditions.multipleConditions) {
        const priceCondition = bumpConfig.conditions.multipleConditions.find(c => 
            c.type === 'price-total' && c.minTotalPrice
        );
        return priceCondition?.minTotalPrice || 0;
    }
    return bumpConfig.conditions.minTotalPrice || 0;
}

/**
 * Replace ALL placeholders in message template
 * @param {string} template - Message template with placeholders
 * @param {Object} bumpConfig - Bump configuration
 * @param {Object} conditionStatus - Condition status
 * @returns {string} - Message with replaced placeholders
 */
function replacePlaceholdersInMessage(template, bumpConfig, conditionStatus) {
    let message = template;
    
    // Replace all known placeholders
    Object.values(NOTIFICATION_PLACEHOLDERS).forEach(placeholder => {
        // Skip {conditions} as it's handled separately
        if (placeholder === '{conditions}') return;
        
        const regex = new RegExp(placeholder.replace(/[{}]/g, '\\{\\}'), 'g');
        const value = getPlaceholderValue(placeholder, bumpConfig, conditionStatus);
        message = message.replace(regex, value);
    });
    
    return message;
}

/**
 * Generate list-based message for multiple products
 * @param {string} combineLogic - 'all' or 'any'
 * @param {Object} bumpConfig - Bump configuration
 * @param {Array} productDetails - Array of product condition details
 * @returns {string} - Formatted HTML message with list
 */
function getMultipleProductsMessage(combineLogic, bumpConfig, productDetails) {
    const templates = window.cartConfig.notifications?.messages?.multipleProducts?.[combineLogic];
    
    if (!templates) {
        return `Tambah produk yang diperlukan untuk unlock ${bumpConfig.productName}`;
    }
    
    // Get heading template
    let heading = templates.heading || 'Sila penuhi syarat berikut untuk unlock {bumpName}:';
    // ‚úÖ FIXED: Pass proper context so {bumpName} gets replaced
    heading = replacePlaceholdersInMessage(heading, bumpConfig, { met: false });
    
    // Get item template
    const itemTemplate = templates.itemTemplate || 
        'Perlukan {productQuantity} unit {productName}. Sekarang ada {currentProductQuantity} unit dalam cart, perlu tambah lagi {remainingProduct} unit.';
    
    // Build list items
    const listItems = productDetails.map((detail, index) => {
        const productData = getProductDataById(detail.id);
        const productName = productData?.name || `Produk ${detail.id}`;
        
        // STANDARDIZED: Use 'remaining' directly for context
        const itemContext = {
            productDetails: [detail],
            remaining: detail.remaining,
            remainingProduct: detail.remaining,
        };
        
        let itemText = replacePlaceholdersInMessage(itemTemplate, {
            ...bumpConfig,
            conditions: {
                requiredProduct: { id: detail.id }
            }
        }, itemContext);
        
        return `<li>${itemText}</li>`;
    }).join('');
    
    return `
        <div class="multi-product-notification">
            <div class="notification-heading">${heading}</div>
            <ol class="notification-list">${listItems}</ol>
        </div>
    `;
}

/**
 * Get pending message with user-defined templates
 * @param {string} condType - Condition type (DEPRECATED - not used anymore)
 * @param {Object} bumpConfig - Bump configuration
 * @param {Object} conditionStatus - Condition status
 * @returns {string} - Formatted message
 */
function getPendingMessage(condType, bumpConfig, conditionStatus) {
    const defaultMessages = window.cartConfig.notifications?.messages || {};
    
    // ========== VALIDATE: Must use multipleConditions ==========
    if (!bumpConfig.conditions.multipleConditions) {
        console.error('‚ùå Invalid condition format. Order bumps MUST use multipleConditions array.');
        console.info('Example:\n{\n  multipleConditions: [\n    { type: "total", minTotalQuantity: 5 },\n    { type: "product", requiredProduct: { id: 1, minQuantity: 2 }}\n  ],\n  combineLogic: "all"\n}');
        return `‚ö†Ô∏è Invalid configuration for ${bumpConfig.productName}`;
    }
    
    // ========== HANDLE MULTIPLE CONDITIONS ==========
    const combineLogic = bumpConfig.conditions.combineLogic || 'all';
    const unmetConditions = conditionStatus.conditionResults?.filter(c => !c.met) || [];
    
    // Get template from config
    const multipleConfig = defaultMessages['multiple']?.[combineLogic];
    let customTemplate = null;
    
    if (typeof multipleConfig === 'string') {
        customTemplate = multipleConfig;
    } else if (multipleConfig && typeof multipleConfig === 'object') {
        customTemplate = multipleConfig.pending;
    }
    
    // If no custom template, use fallback
    if (!customTemplate) {
        const fallbackTemplates = {
            all: 'Sila penuhi semua syarat: {conditions} untuk unlock {bumpName}',
            any: 'Penuhi salah satu syarat: {conditions} untuk unlock {bumpName}'
        };
        customTemplate = fallbackTemplates[combineLogic];
    }
    
    // ========== COMBINE LOGIC: ALL ==========
    if (combineLogic === 'all') {
        const messages = unmetConditions.map(c => {
            return getConditionMessage(c.type, c.details, bumpConfig, conditionStatus);
        }).filter(m => m);
        
        if (messages.length === 0) {
            return `Unlock ${bumpConfig.productName}`;
        }
        
        // Wrap conditions properly (list-based messages stay as-is)
        const wrappedConditions = messages.map(m => {
            if (m.includes('<div class="multi-product-notification">')) {
                return m; // Don't wrap list-based messages
            }
            return `<strong>${m}</strong>`;
        });
        
        // Combine multiple conditions with proper formatting
        let conditionsText = '';
        
        if (wrappedConditions.length === 1) {
            conditionsText = wrappedConditions[0];
        } else if (wrappedConditions.length === 2) {
            conditionsText = wrappedConditions.join(' & ');
        } else {
            conditionsText = wrappedConditions.slice(0, -1).join(', ') + ' & ' + wrappedConditions[wrappedConditions.length - 1];
        }
        
        return customTemplate
            .replace(/{conditions}/g, conditionsText)
            .replace(/{bumpName}/g, `<strong>${bumpConfig.productName}</strong>`);
    }
    
    // ========== COMBINE LOGIC: ANY ==========
    if (combineLogic === 'any') {
        const closestCondition = findClosestCondition(unmetConditions);
        
        if (!closestCondition) {
            return `Unlock ${bumpConfig.productName}`;
        }
        
        const conditionText = getConditionMessage(
            closestCondition.type, 
            closestCondition.details, 
            bumpConfig, 
            conditionStatus
        );
        
        // Check if list-based message
        if (conditionText.includes('<div class="multi-product-notification">')) {
            return conditionText; // Return as-is (already has full structure)
        }
        
        return customTemplate
            .replace(/{conditions}/g, `<strong>${conditionText}</strong>`)
            .replace(/{bumpName}/g, `<strong>${bumpConfig.productName}</strong>`);
    }
    
    // ========== FALLBACK (should never reach here) ==========
    console.warn(`‚ö†Ô∏è Unknown combineLogic: ${combineLogic}. Using fallback.`);
    return `Unlock ${bumpConfig.productName}`;
}

/**
 * Get message for a single condition
 * @param {string} condType - Condition type
 * @param {Object} details - Condition details
 * @param {Object} bumpConfig - Bump configuration
 * @param {Object} fullConditionStatus - OPTIONAL: Full condition status for 'both' types
 * @returns {string} - Formatted message
 */
function getConditionMessage(condType, details, bumpConfig, fullConditionStatus = null) {
    switch(condType) {
        case 'total':
            return `${details.remainingTotal} item lagi`;
            
        case 'price-total':
            return `${formatPrice(details.remainingTotalPrice)} lagi`;
            
        case 'product': {
            // Check if multiple products
            if (details.productDetails && details.productDetails.length > 1) {
                let combineLogic = 'all';
                
                if (bumpConfig.conditions.multipleConditions) {
                    const matchingCondition = bumpConfig.conditions.multipleConditions.find(c => 
                        c.type === 'product' && c.requiredProducts && c.requiredProducts.length > 1
                    );
                    if (matchingCondition) {
                        combineLogic = matchingCondition.productCombineLogic || matchingCondition.combineLogic || 'all';
                    }
                } else if (bumpConfig.conditions.requiredProducts && bumpConfig.conditions.requiredProducts.length > 1) {
                    combineLogic = bumpConfig.conditions.productCombineLogic || bumpConfig.conditions.combineLogic || 'all';
                }
                
                // Generate list-based message
                return getMultipleProductsMessage(combineLogic, bumpConfig, details.productDetails);
            }
            
            // Single product
            let productName = 'produk';
            
            if (bumpConfig.conditions.multipleConditions) {
                const matchingCondition = bumpConfig.conditions.multipleConditions.find(c => {
                    if (c.type === 'product' && c.requiredProduct) {
                        return details.productDetails?.some(pd => pd.id === c.requiredProduct.id);
                    }
                    return false;
                });
                
                if (matchingCondition?.requiredProduct) {
                    const productData = getProductDataById(matchingCondition.requiredProduct.id);
                    productName = productData?.name || `Produk ${matchingCondition.requiredProduct.id}`;
                }
            } else if (bumpConfig.conditions.requiredProduct) {
                const productData = getProductDataById(bumpConfig.conditions.requiredProduct.id);
                productName = productData?.name || `Produk ${bumpConfig.conditions.requiredProduct.id}`;
            }
            
            return `${details.remainingProduct} ${productName} lagi`;
        }
            
        case 'price-product': {
            // Check if multiple products
            if (details.productDetails && details.productDetails.length > 1) {
                let combineLogic = 'all';
                
                if (bumpConfig.conditions.multipleConditions) {
                    const matchingCondition = bumpConfig.conditions.multipleConditions.find(c => 
                        c.type === 'price-product' && c.requiredProducts && c.requiredProducts.length > 1
                    );
                    if (matchingCondition) {
                        combineLogic = matchingCondition.productCombineLogic || matchingCondition.combineLogic || 'all';
                    }
                } else if (bumpConfig.conditions.requiredProducts && bumpConfig.conditions.requiredProducts.length > 1) {
                    combineLogic = bumpConfig.conditions.productCombineLogic || bumpConfig.conditions.combineLogic || 'all';
                }
                
                // Generate list-based message for prices
                return getMultipleProductsPriceMessage(combineLogic, bumpConfig, details.productDetails);
            }
            
            // Single product
            let productName = 'produk';
            
            if (bumpConfig.conditions.multipleConditions) {
                const matchingCondition = bumpConfig.conditions.multipleConditions.find(c => {
                    if (c.type === 'price-product' && c.requiredProduct) {
                        return details.productDetails?.some(pd => pd.id === c.requiredProduct.id);
                    }
                    return false;
                });
                
                if (matchingCondition?.requiredProduct) {
                    const productData = getProductDataById(matchingCondition.requiredProduct.id);
                    productName = productData?.name || `Produk ${matchingCondition.requiredProduct.id}`;
                }
            } else if (bumpConfig.conditions.requiredProduct) {
                const productData = getProductDataById(bumpConfig.conditions.requiredProduct.id);
                productName = productData?.name || `Produk ${bumpConfig.conditions.requiredProduct.id}`;
            }
            
            return `${formatPrice(details.remainingProductPrice)} lagi untuk ${productName}`;
        }
            
        default:
            return '';
    }
}

function getMultipleProductsPriceMessage(combineLogic, bumpConfig, productDetails) {
    const templates = window.cartConfig.notifications?.messages?.multipleProducts?.[combineLogic];
    
    if (!templates) {
        return `Tambah harga produk yang diperlukan untuk unlock ${bumpConfig.productName}`;
    }
    
    let heading = templates.priceHeading || templates.heading || 'Sila penuhi syarat berikut untuk unlock {bumpName}:';
    // ‚úÖ FIXED: Pass proper context so {bumpName} gets replaced
    heading = replacePlaceholdersInMessage(heading, bumpConfig, { met: false });
    
    const itemTemplate = templates.priceItemTemplate || 
        'Perlukan {productPrice} untuk {productName}. Sekarang ada {currentProductPrice} dalam cart, perlu tambah lagi {remainingProductPrice}.';
    
    const listItems = productDetails.map((detail, index) => {
        const productData = getProductDataById(detail.id);
        const productName = productData?.name || `Produk ${detail.id}`;
        
        const itemContext = {
            productDetails: [detail],
            remaining: detail.remaining,
            remainingProductPrice: detail.remaining,
        };
        
        let itemText = replacePlaceholdersInMessage(itemTemplate, {
            ...bumpConfig,
            conditions: {
                requiredProduct: { id: detail.id }
            }
        }, itemContext);
        
        return `<li>${itemText}</li>`;
    }).join('');
    
    return `
        <div class="multi-product-notification">
            <div class="notification-heading">${heading}</div>
            <ol class="notification-list">${listItems}</ol>
        </div>
    `;
}

/**
 * Find the closest condition to being met
 */
function findClosestCondition(unmetConditions) {
    if (unmetConditions.length === 0) return null;
    
    // Simple heuristic: condition with smallest remaining value
    return unmetConditions.reduce((closest, current) => {
        const closestRemaining = getSmallestRemaining(closest.details);
        const currentRemaining = getSmallestRemaining(current.details);
        return currentRemaining < closestRemaining ? current : closest;
    });
}

/**
 * Get smallest remaining value from a condition result
 */
function getSmallestRemaining(details) {
    const values = [
        details.remainingTotal,
        details.remainingProduct,
        details.remainingTotalPrice,
        details.remainingProductPrice
    ].filter(v => v > 0);
    
    return values.length > 0 ? Math.min(...values) : Infinity;
}

function getSuccessMessage(condType, bumpName, bumpConfig) {
    const defaultMessages = window.cartConfig.notifications?.messages || {};
    
    // ONLY support multiple conditions
    if (bumpConfig && bumpConfig.conditions && bumpConfig.conditions.multipleConditions) {
        const combineLogic = bumpConfig.conditions.combineLogic || 'all';
        
        const multipleConfig = defaultMessages['multiple']?.[combineLogic];
        let multipleSuccessMsg = null;
        
        if (typeof multipleConfig === 'object' && multipleConfig.success) {
            multipleSuccessMsg = multipleConfig.success;
        }
        
        if (multipleSuccessMsg) {
            // Use centralized placeholder replacement
            return replacePlaceholdersInMessage(
                multipleSuccessMsg, 
                bumpConfig, 
                { met: true } // Empty status for success message
            );
        }
        
        // Fallback
        const fallbackMsg = defaultMessages['multiple']?.success || 
                           'Tahniah! Anda layak untuk {bumpName} pada harga diskaun';
        
        return replacePlaceholdersInMessage(fallbackMsg, bumpConfig, { met: true });
    }
    
    // ‚ùå ERROR: Must use multipleConditions
    console.error('‚ùå Invalid condition format. Please use multipleConditions.');
    return `Tahniah! Anda layak untuk <strong>${bumpName}</strong>`;
}

/**
 * Create or update notification for order bump conditions
 * @param {number} bumpIndex - Index of the order bump
 * @param {Object} conditionStatus - Status of conditions (met, remaining counts, etc)
 */
function updateBumpNotification(bumpIndex, conditionStatus) {
    if (!window.cartConfig.notifications.enabled) return;

    const bumpConfig = window.cartConfig.orderBumps[bumpIndex];
    
    if (!bumpConfig || !bumpConfig.conditions) return;
    
    // Check if it's a valid condition config (either has type OR multipleConditions)
    const hasValidConditions = bumpConfig.conditions.type || 
                               (bumpConfig.conditions.multipleConditions && 
                                Array.isArray(bumpConfig.conditions.multipleConditions));
    
    if (!hasValidConditions) return;

    const notificationId = `bump-notification-${bumpIndex}`;
    let notification = document.getElementById(notificationId);
    const bumpContainer = document.querySelector(`.order-bump-container[data-bump-index="${bumpIndex}"]`);

    // If conditions are met
    if (conditionStatus.met) {
        if (notification) {
            if (window.cartConfig.notifications.showSuccessMessage) {
                
                const message = getSuccessMessage(bumpConfig.conditions.type, bumpConfig.productName, bumpConfig);

                notification.className = 'order-bump-notification success';
                notification.innerHTML = `
                    <div class="order-bump-notification-content">
                        <div class="order-bump-notification-icon">
                            <i class="fa fa-check"></i>
                        </div>
                        <div class="order-bump-notification-text">
                            <div class="order-bump-notification-message">${message}</div>
                        </div>
                    </div>
                `;

                setTimeout(() => {
                    if (notification && notification.parentNode) {
                        notification.style.animation = 'slideInNotification 0.3s ease reverse';
                        setTimeout(() => {
                            if (notification && notification.parentNode) {
                                notification.remove();
                            }
                        }, 300);
                    }
                }, 5000);
            } else {
                if (notification && notification.parentNode) {
                    notification.remove();
                }
            }
        }
        return;
    }

    // If conditions are not met and user has started ordering
    if (!conditionStatus.met && conditionStatus.hasStarted) {
        // ‚úÖ Use updated getPendingMessage with user-defined template
        const message = getPendingMessage(bumpConfig.conditions.type, bumpConfig, conditionStatus);

        // Create or update notification
        if (!notification) {
            notification = document.createElement('div');
            notification.id = notificationId;
            notification.className = 'order-bump-notification';

            if (bumpContainer) {
                bumpContainer.insertAdjacentElement('beforebegin', notification);
            } else {
                const { targetElement, insertMethod } = getOrderBumpInsertTarget();
                if (targetElement) {
                    targetElement.insertAdjacentElement(insertMethod === 'beforebegin' ? 'beforebegin' : 'afterend', notification);
                }
            }
        }

        notification.innerHTML = `
            <div class="order-bump-notification-content">
                <div class="order-bump-notification-text">
                    <div class="order-bump-notification-message">${message}</div>
                </div>
            </div>
        `;
    } else {
        if (notification && notification.parentNode) {
            notification.remove();
        }
    }
}

function getProductDataById(productId) {
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (!productRow) {
        console.warn(`Product with ID ${productId} not found`);
        return null;
    }
    
    const productNameCell = productRow.querySelector('td:first-child');
    const productName = productNameCell ? productNameCell.textContent.trim() : '';
    
    if (window.cartConfig.debugMode) {
        console.log(`üì¶ Product ${productId} found:`, productName);
    }
    
    return {
        id: productId,
        name: productName,
    };
}

function formatPrice(price) {
    const formatted = price.toFixed(window.cartConfig.currency.decimalPlaces);
    if (window.cartConfig.currency.position === 'before') {
        return `${window.cartConfig.currency.symbol}${formatted}`;
    }
    return `${formatted}${window.cartConfig.currency.symbol}`;
}

function formatCartTotal(amount) {
    return amount;
}

function calculateSavings(originalPrice, discountedPrice) {
    return originalPrice - discountedPrice;
}

function replacePlaceholders(template, bumpConfig) {
    const savings = calculateSavings(bumpConfig.originalPrice, bumpConfig.discountedPrice);
    const savingsText = bumpConfig.savingsText.replace('{amount}', formatPrice(savings));
    
    // Mapping placeholders to their CSS classes
    const placeholderMap = {
        '{productName}': {
            value: bumpConfig.productName,
            class: 'bump-product-name'
        },
        '{oldPrice}': {
            value: formatPrice(bumpConfig.originalPrice),
            class: 'bump-price-old'
        },
        '{newPrice}': {
            value: formatPrice(bumpConfig.discountedPrice),
            class: 'bump-price-new'
        },
        '{savings}': {
            value: savingsText,
            class: 'bump-save'
        }
    };
    
    // Replace each placeholder with wrapped HTML
    let result = template;
    
    Object.entries(placeholderMap).forEach(([placeholder, config]) => {
        // Create regex to find placeholder (case insensitive for safety)
        const regex = new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'gi');
        
        // Replace with wrapped span
        result = result.replace(regex, `<span class="${config.class}">${config.value}</span>`);
    });
    
    return result;
}

function processBumpConfig(bumpConfig) {
    if (bumpConfig.productId) {
        const productData = getProductDataById(bumpConfig.productId);
        
        if (productData) {
            if (!bumpConfig.productName) {
                bumpConfig.productName = productData.name;
            }

            if (productData.price && !bumpConfig.discountedPrice) {
                bumpConfig.discountedPrice = productData.price;
            }
        }
    }
    
    if (!bumpConfig.productName) {
        console.error('Order bump missing productName:', bumpConfig);
        return null;
    }
    
    if (!bumpConfig.discountedPrice) {
        console.error('Order bump missing discountedPrice:', bumpConfig);
        return null;
    }
    
    return bumpConfig;
}

function syncOrderBumpToProduct(bumpIndex, quantity) {
    const bumpConfig = window.cartConfig.orderBumps[bumpIndex];
    
    if (!bumpConfig || !bumpConfig.productId) {
        console.warn(`Order bump ${bumpIndex} tidak mempunyai productId`);
        return false;
    }
    
    const productRow = document.querySelector(`.product[data-id="${bumpConfig.productId}"]`);
    
    if (!productRow) {
        console.warn(`Product dengan ID ${bumpConfig.productId} tidak dijumpai`);
        return false;
    }
    
    const selectElement = productRow.querySelector('select.quantity');
    
    if (selectElement) {
        // Prevent infinite loop
        selectElement.dataset.fromBump = 'true';
        
        if (typeof $ !== 'undefined' && $.fn.select2) {

            $(selectElement).val(quantity.toString());
            $(selectElement).trigger('change.select2');
            
            // Trigger input event
            setTimeout(() => {
                const inputEvent = new Event('input', { bubbles: true });
                selectElement.dispatchEvent(inputEvent);
            }, 50);
            
        } else {
            selectElement.value = quantity.toString();
            selectElement.dispatchEvent(new Event('change', { bubbles: true }));
            selectElement.dispatchEvent(new Event('input', { bubbles: true }));
        }
        
        if (window.cartConfig.debugMode) {
            console.log(`‚úÖ Product ${bumpConfig.productId} (${bumpConfig.productName}) quantity set to: ${quantity}`);
        }
        
        return true;
    }
    
    return false;
}

function clearProductQuantity(bumpIndex) {
    return syncOrderBumpToProduct(bumpIndex, 0);
}

function hideProductInTable(productId) {
    // Cari product row dengan data-id yang sepadan
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (productRow) {
        // Set visibility collapse dan opacity 0
        productRow.style.visibility = 'collapse';
        productRow.style.opacity = '0';
        
        if (window.cartConfig.debugMode) {
            console.log(`üôà Product ${productId} hidden from table`);
        }
    }
}

function hideOrderBumpProducts() {
    // Loop semua order bumps yang enabled dan ada productId
    window.cartConfig.orderBumps.forEach((bump, index) => {
        if (bump.enabled && bump.productId) {
            hideProductInTable(bump.productId);
        }
    });
}

function showProductAsOrderBump(productId, quantity) {
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (productRow) {
        // Show product row
        productRow.style.visibility = 'visible';
        productRow.style.opacity = '1';
        
        // Tambah order bump badge kalau belum ada
        const productNameCell = productRow.querySelector('td:first-child');
        if (productNameCell && !productNameCell.querySelector('.order-bump-badge-table')) {
            const badge = document.createElement('span');
            badge.className = 'order-bump-badge-table';
            badge.textContent = window.cartConfig.bumpsBadge.text;
            productNameCell.insertBefore(badge, productNameCell.firstChild);
            
            // Add space after badge
            productNameCell.insertBefore(document.createTextNode(' '), badge.nextSibling);
        }
        
        // Disable quantity selector
        const quantitySelect = productRow.querySelector('.quantity');
        if (quantitySelect) {
            quantitySelect.disabled = true;
            quantitySelect.style.opacity = '0.6';
            quantitySelect.style.cursor = 'not-allowed';
        }
        
        if (window.cartConfig.debugMode) {
            console.log(`üëÅÔ∏è Product ${productId} shown as Order Bump`);
        }
    }
}

function resetProductInTable(productId) {
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (productRow) {
        // Hide product row again
        productRow.style.visibility = 'collapse';
        productRow.style.opacity = '0';
        
        // Remove order bump badge
        const badge = productRow.querySelector('.order-bump-badge-table');
        if (badge) {
            badge.remove();
            // Remove space after badge if exists
            const nextNode = productRow.querySelector('td:first-child').childNodes[0];
            if (nextNode && nextNode.nodeType === 3 && nextNode.textContent.trim() === '') {
                nextNode.remove();
            }
        }
        
        // Enable quantity selector dan reset ke 0
        const quantitySelect = productRow.querySelector('.quantity');
        if (quantitySelect) {
            quantitySelect.disabled = false;
            quantitySelect.style.opacity = '1';
            quantitySelect.style.cursor = 'pointer';
        }
        
        if (window.cartConfig.debugMode) {
            console.log(`üîÑ Product ${productId} reset and hidden`);
        }
    }
}

/**
 * Get the target element where order bumps should be inserted
 * @returns {Object} - Object containing targetElement and insertMethod
 */
function getOrderBumpInsertTarget() {
    const location = window.cartConfig.orderBumpsLocation;
    let targetElement = null;
    let insertMethod = 'beforebegin';
    
    switch(location.position) {
        case 'before-payment':
            targetElement = document.getElementById('payment-section');
            insertMethod = 'beforebegin';
            break;
            
        case 'after-products':
            targetElement = document.querySelector('.table.table-condensed.purchase_details:not(.table-hover)');
            insertMethod = 'afterend';
            break;
            
        case 'before-customer':
            targetElement = document.querySelector('h2.section-header'); // First section header (BUTIRAN PELANGGAN)
            insertMethod = 'beforebegin';
            break;
            
        case 'custom':
            targetElement = document.querySelector(location.customSelector);
            insertMethod = location.insertMethod || 'afterend';
            break;
            
        default:
            // Fallback to before payment
            targetElement = document.getElementById('payment-section');
            insertMethod = 'beforebegin';
    }
    
    if (!targetElement) {
        console.error(`‚ùå Order bump target element not found for position: ${location.position}`);
        // Try fallback to payment section
        targetElement = document.getElementById('payment-section');
        insertMethod = 'beforebegin';
    }
    
    if (window.cartConfig.debugMode) {
        console.log(`üìç Order bump insert target:`, {
            position: location.position,
            element: targetElement,
            method: insertMethod
        });
    }
    
    return { targetElement, insertMethod };
}

/**
 * Get quantity for a specific product
 * @param {number} productId - The product ID to check
 * @returns {number} - Current quantity of the product
 */
function getProductQuantity(productId) {
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (!productRow) {
        return 0;
    }
    
    const selectElement = productRow.querySelector('select.quantity');
    
    if (selectElement) {
        return parseInt(selectElement.value) || 0;
    }
    
    return 0;
}

/**
 * Get total quantity from cart
 * @returns {number} - Total quantity in cart
 */
function getTotalQuantity() {
    const totalQuantityElement = document.querySelector('.total-quantity');
    
    if (totalQuantityElement) {
        return parseInt(totalQuantityElement.textContent) || 0;
    }
    
    return 0;
}

/**
 * Check if order bump conditions are met
 * @param {Object} bumpConfig - The order bump configuration
 * @returns {boolean} - True if conditions are met, false otherwise
 */
function checkBumpConditions(bumpConfig) {
    const detailed = checkBumpConditionsDetailed(bumpConfig);
    return detailed.met;
}

/**
 * Update visibility for a single order bump
 * @param {number} bumpIndex - Index of the order bump in window.cartConfig.orderBumps
 */
function updateBumpVisibility(bumpIndex) {
    const bumpConfig = window.cartConfig.orderBumps[bumpIndex];
    
    if (!bumpConfig || !bumpConfig.enabled) {
        return;
    }
    
    const bumpContainer = document.querySelector(`.order-bump-container[data-bump-index="${bumpIndex}"]`);
    
    if (!bumpContainer) {
        return;
    }
    
    // Get detailed condition status
    const conditionStatus = checkBumpConditionsDetailed(bumpConfig);
    const shouldShow = conditionStatus.met;
    const hasStarted = conditionStatus.hasStarted;
    
    // Update notification
    updateBumpNotification(bumpIndex, conditionStatus);
    
    // Get checkbox reference
    const checkbox = bumpContainer.querySelector('.order-bump-input');
    const quantityWrapper = bumpContainer.querySelector('.order-bump-quantity-wrapper');
    
    // Show bump bila user dah mula order
    if (hasStarted || shouldShow) {
        bumpContainer.style.display = 'block';
        
        if (!shouldShow) {
            // Conditions not met - DISABLE bump
            bumpContainer.classList.add('disabled');
            
            if (checkbox) {
                checkbox.disabled = true;
                
                // Uncheck dan trigger event untuk clear product dari table
                if (checkbox.checked) {
                    checkbox.checked = false;
                    // Trigger change event manually
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }
            
            // Hide quantity wrapper jika ada
            if (quantityWrapper) {
                quantityWrapper.style.display = 'none';
            }
            
            if (window.cartConfig.debugMode) {
                console.log(`√∞≈∏"' Order bump ${bumpIndex} shown but DISABLED (conditions not met)`);
            }
        } else {
            // Conditions met - ENABLE bump
            bumpContainer.classList.remove('disabled');
            if (checkbox) {
                checkbox.disabled = false;
            }
            
            if (window.cartConfig.debugMode) {
                console.log(`Order bump ${bumpIndex} ENABLED (conditions met)`);
            }
        }
    } else {
        // User belum mula order - HIDE bump sepenuhnya
        bumpContainer.style.display = 'none';
        
        // Uncheck dan trigger event untuk clear product dari table
        if (checkbox && checkbox.checked) {
            checkbox.checked = false;
            // Trigger change event manually
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        
        if (window.cartConfig.debugMode) {
            console.log(`Order bump ${bumpIndex} hidden (user hasn't started ordering)`);
        }
    }
}

/**
 * Update visibility for all order bumps
 */
function updateAllBumpVisibility() {
    window.cartConfig.orderBumps.forEach((bump, index) => {
        if (bump.enabled) {
            updateBumpVisibility(index);
        }
    });
}

/**
 * Setup monitoring for quantity changes
 * Monitors both product quantities and total quantity
 */
function setupQuantityMonitoring() {
    // Monitor semua product quantity selectors
    const allQuantitySelectors = document.querySelectorAll('.product select.quantity');
    
    allQuantitySelectors.forEach(selector => {
        // Monitor changes via select2 if available
        if (typeof $ !== 'undefined' && $.fn.select2) {
            $(selector).on('change.select2', function() {
                // Delay sikit untuk pastikan value dah update
                setTimeout(() => {
                    updateAllBumpVisibility();
                }, 100);
            });
        }
        
        // Fallback to native change event
        selector.addEventListener('change', function() {
            setTimeout(() => {
                updateAllBumpVisibility();
            }, 100);
        });
        
        selector.addEventListener('input', function() {
            setTimeout(() => {
                updateAllBumpVisibility();
            }, 100);
        });
    });
    
    // Monitor total quantity changes
    const totalQuantityElement = document.querySelector('.total-quantity');
    
    if (totalQuantityElement) {
        const observer = new MutationObserver(() => {
            updateAllBumpVisibility();
        });
        
        observer.observe(totalQuantityElement, {
            childList: true,
            characterData: true,
            subtree: true
        });

        setupPriceMonitoring();
        
        if (window.cartConfig.debugMode) {
            console.log('üëÄ Quantity monitoring setup complete');
        }
    }
}

// Separate function untuk setup listeners
function setupOrderBumpListeners() {
    document.querySelectorAll('.order-bump-input').forEach(checkbox => {
        const index = parseInt(checkbox.getAttribute('data-bump-index'));
        const bumpConfig = processBumpConfig(window.cartConfig.orderBumps[index]);
        if (!bumpConfig) return;
        
        const bumpId = `order-bump-${index}`;
        const quantityWrapper = document.getElementById(`${bumpId}-quantity-wrapper`);
        const qtyInput = document.getElementById(`${bumpId}-qty-input`);
        const bumpTotalPrice = document.getElementById(`${bumpId}-total-price`);
        const minusBtn = document.querySelector(`.qty-minus[data-bump-index="${index}"]`);
        const plusBtn = document.querySelector(`.qty-plus[data-bump-index="${index}"]`);
        
        function updateBumpTotal() {
            const quantity = parseInt(qtyInput.value) || 1;
            const total = bumpConfig.discountedPrice * quantity;
            bumpTotalPrice.textContent = formatPrice(total);
            
            if (checkbox.checked) {
                syncOrderBumpToProduct(index, quantity);
            }
            
            if (window.cartConfig.debugMode) {
                console.log(`Order bump ${index} total: ${formatPrice(total)}`);
            }
        }

        function updateQuantityButtons() {
            const currentValue = parseInt(qtyInput.value) || 1;
            if (minusBtn) {
                minusBtn.disabled = (currentValue <= bumpConfig.minQuantity);
            }
            if (plusBtn) {
                plusBtn.disabled = (currentValue >= bumpConfig.maxQuantity);
            }
        }

        // Set initial button states
        updateQuantityButtons();
        
        checkbox.addEventListener('change', function() {
            if (this.checked) {
                quantityWrapper.style.display = 'flex';
                const initialQty = parseInt(qtyInput.value) || bumpConfig.defaultQuantity;
                
                setTimeout(() => {
                    syncOrderBumpToProduct(index, initialQty);
                }, 100);
                
                updateBumpTotal();

                // Show product dalam table dengan quantity dari order bump
                if (bumpConfig.productId) {
                    const currentQty = parseInt(qtyInput.value) || bumpConfig.defaultQuantity;
                    showProductAsOrderBump(bumpConfig.productId, currentQty);
                }
                
                if (window.cartConfig.debugMode) {
                    console.log(`‚úÖ Order bump ${index} selected:`, bumpConfig.productName);
                }
            } else {
                quantityWrapper.style.display = 'none';
                clearProductQuantity(index);

                // Hide product dalam table semula
                if (bumpConfig.productId) {
                    resetProductInTable(bumpConfig.productId);
                }
                
                if (window.cartConfig.debugMode) {
                    console.log(`‚ùå Order bump ${index} deselected`);
                }
            }
        });
        
        if (minusBtn) {
            minusBtn.addEventListener('click', function(e) {
                e.preventDefault();
                let currentValue = parseInt(qtyInput.value) || 1;
                if (currentValue > bumpConfig.minQuantity) {
                    qtyInput.value = currentValue - 1;
                    updateBumpTotal();
                    updateQuantityButtons();
                }
            });
        }
        
        if (plusBtn) {
            plusBtn.addEventListener('click', function(e) {
                e.preventDefault();
                let currentValue = parseInt(qtyInput.value) || 1;
                if (currentValue < bumpConfig.maxQuantity) {
                    qtyInput.value = currentValue + 1;
                    updateBumpTotal();
                    updateQuantityButtons();
                }
            });
        }
        
        if (qtyInput) {
            qtyInput.addEventListener('change', function() {
                let value = parseInt(this.value) || 1;
                
                if (value < bumpConfig.minQuantity) value = bumpConfig.minQuantity;
                if (value > bumpConfig.maxQuantity) value = bumpConfig.maxQuantity;
                
                this.value = value;
                updateBumpTotal();
                updateQuantityButtons();
            });
        }
    });
}

function init() {
    // Check if config exists
    if (!window.cartConfig) {
        console.error('cartConfig not found! Please define window.cartConfig before loading this script.');
        return;
    }

    injectCartHTML();

    const cartForm = document.getElementById('form');
    const toggleBtn = document.getElementById('cart-toggle-btn');
    const cartQty = document.getElementById('cartQty');
    const formOverlay = document.getElementById('form-overlay');

    toggleBtn.addEventListener('click', function () {
        cartForm.classList.toggle('active');
        toggleBtn.classList.toggle('active');
        formOverlay.classList.toggle('active');
    });

    formOverlay.addEventListener('click', function() {
        cartForm.classList.remove('active');
        toggleBtn.classList.remove('active');
        formOverlay.classList.remove('active');
    });

    function updateCartCount() {
        const totalQuantityElement = document.querySelector('.total-quantity');
        if (totalQuantityElement) {
            const totalCount = parseInt(totalQuantityElement.textContent) || 0;
            cartQty.setAttribute('data-count', totalCount);
        }
    }

    const totalQuantityElement = document.querySelector('.total-quantity');
    if (totalQuantityElement) {
        updateCartCount();
        const observer = new MutationObserver(updateCartCount);
        observer.observe(totalQuantityElement, {
            childList: true,
            characterData: true,
            subtree: true
        });
    }

    function updateTotalAmount() {
        const totalAmountElement = document.querySelector('.total-amount');
        const cartTotalDisplay = document.querySelector('.cart-total');
        
        if (totalAmountElement && cartTotalDisplay) {
            const totalAmount = totalAmountElement.textContent.trim();
            cartTotalDisplay.textContent = totalAmount;
        }
    }

    const totalAmountElement = document.querySelector('.total-amount');
    if (totalAmountElement) {
        updateTotalAmount();
        const amountObserver = new MutationObserver(updateTotalAmount);
        amountObserver.observe(totalAmountElement, { 
            childList: true, 
            characterData: true, 
            subtree: true 
        });
    }

    document.querySelectorAll('input[type="radio"]').forEach(radio => {
        const customDiv = document.createElement('div');
        customDiv.className = 'checkbox-custom';
        radio.insertAdjacentElement('afterend', customDiv);
    });
}

// ========== INITIALIZE CART ==========
document.addEventListener('DOMContentLoaded', function() {
    init();
    
    // Set toggle button text
    const toggleBtnText = document.querySelector('.toggle-btn-txt');
    if (toggleBtnText) {
        toggleBtnText.textContent = window.cartConfig.cartButton.text;
    }
    
    // Set currency symbol in cart total
    const cartTotalElement = document.querySelector('.cart-total');
    if (cartTotalElement && window.cartConfig.currency.position === 'before') {
        cartTotalElement.style.setProperty('--currency-symbol', `"${window.cartConfig.currency.symbol}"`);
    } else if (cartTotalElement && window.cartConfig.currency.position === 'after') {
        const style = document.createElement('style');
        style.textContent = `
            .left-section .cart-total::before { content: none !important; }
            .left-section .cart-total::after { content: "${window.cartConfig.currency.symbol}"; margin-left: 2px; }
        `;
        document.head.appendChild(style);
    }
    
    const cartForm = document.getElementById('form');
    
    if (cartForm && !cartForm.classList.contains('active')) {
        cartForm.style.visibility = 'hidden';
        setTimeout(function() {
            cartForm.style.visibility = 'visible';
        }, 200);
    }

    hideOrderBumpProducts();
    setupQuantityMonitoring();

    const { targetElement, insertMethod } = getOrderBumpInsertTarget();

    if (targetElement) {
        window.cartConfig.orderBumps.forEach((bumpConfig, index) => {
            if (!bumpConfig.enabled) return;
            
            // ‚úÖ Process config first
            const processedConfig = processBumpConfig(bumpConfig);
            if (!processedConfig) {
                console.error(`Order bump ${index} skipped due to invalid config`);
                return;
            }
            
            // ‚úÖ Generate HTML variables
            const titleHTML = replacePlaceholders(processedConfig.title, processedConfig);
            const descriptionHTML = replacePlaceholders(processedConfig.description, processedConfig);
            const bumpId = `order-bump-${index}`;
            
            const orderBumpHTML = `
                <div class="order-bump-container" data-bump-index="${index}">
                    <div class="order-bump-badge">
                        <i class="fa ${processedConfig.badgeIcon}"></i> ${processedConfig.badgeText}
                    </div>
                    <div class="order-bump-content">
                        <label class="order-bump-checkbox">
                            <input type="checkbox" id="${bumpId}-checkbox" class="order-bump-input" value="1" data-bump-index="${index}">
                            <span class="checkmark"></span>
                            <div class="order-bump-text">
                                <div class="order-bump-title">${titleHTML}</div>
                                <div class="order-bump-description">${descriptionHTML}</div>
                            </div>
                        </label>
                        <div class="order-bump-quantity-wrapper" id="${bumpId}-quantity-wrapper" style="display: none;">
                            <div class="bump-quantity-left">
                                <div class="quantity-label">${processedConfig.quantityLabel}</div>
                                <div class="quantity-selector">
                                    <button type="button" class="qty-btn qty-minus" data-bump-index="${index}">
                                        <i class="fa fa-minus"></i>
                                    </button>
                                    <input type="number" class="qty-input" id="${bumpId}-qty-input" value="${processedConfig.defaultQuantity}" min="${processedConfig.minQuantity}" max="${processedConfig.maxQuantity}" readonly data-bump-index="${index}">
                                    <button type="button" class="qty-btn qty-plus" data-bump-index="${index}">
                                        <i class="fa fa-plus"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="quantity-total">
                                <span class="bump-total-price" id="${bumpId}-total-price">${formatPrice(processedConfig.discountedPrice)}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            targetElement.insertAdjacentHTML(insertMethod, orderBumpHTML);
        });
        
        setTimeout(() => {
            setupOrderBumpListeners();
            updateAllBumpVisibility();
        }, 500);
        
        if (window.cartConfig.debugMode) {
            console.log('üéÅ Order Bumps loaded:', window.cartConfig.orderBumps.filter(b => b.enabled).length, 'active');
        }
    }
});

})();
