(function() {
    'use strict';

// ========== INJECT CART HTML STRUCTURE ==========
function injectCartHTML() {
    const cartHTML = `
        <div class="cart-container">
            <div class="left-section">
                <i class="fa fa-shopping-cart" id="cartQty" data-count="0"></i>
                <span class="cart-total">0.00</span>
            </div>
            <div class="right-section">
                <button id="cart-toggle-btn">
                    <span class="toggle-btn-txt">TEMPAH SEKARANG</span>
                    <i class="fa fa-times"></i>
                </button>
            </div>
        </div>
        <div id="form-overlay"></div>
    `;

    // Inject at the end of body
    document.body.insertAdjacentHTML('beforeend', cartHTML);
}

// ========== UTILITY FUNCTIONS ==========
/**
 * Get price for a specific product (unit price √ó quantity)
 * @param {number} productId - The product ID to check
 * @returns {number} - Total price of the product (price √ó qty)
 */
function getProductPrice(productId) {
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (!productRow) {
        return 0;
    }
    
    // Get subtotal price from table
    const subtotalCell = productRow.querySelector('.subtotal-price');
    
    if (subtotalCell) {
        const priceText = subtotalCell.textContent.trim();
        return parseFloat(priceText) || 0;
    }
    
    return 0;
}

/**
 * Get total price from cart
 * @returns {number} - Total price in cart
 */
function getTotalPrice() {
    const totalPriceElement = document.querySelector('.total-price');
    
    if (totalPriceElement) {
        const priceText = totalPriceElement.textContent.trim();
        return parseFloat(priceText) || 0;
    }
    
    return 0;
}

/**
 * Setup monitoring for price changes
 */
function setupPriceMonitoring() {
    // Monitor subtotal price elements
    const subtotalElements = document.querySelectorAll('.subtotal-price');
    
    subtotalElements.forEach(element => {
        const observer = new MutationObserver(() => {
            updateAllBumpVisibility();
        });
        
        observer.observe(element, {
            childList: true,
            characterData: true,
            subtree: true
        });
    });
    
    // Monitor total price element
    const totalPriceElement = document.querySelector('.total-price');
    
    if (totalPriceElement) {
        const observer = new MutationObserver(() => {
            updateAllBumpVisibility();
        });
        
        observer.observe(totalPriceElement, {
            childList: true,
            characterData: true,
            subtree: true
        });
    }
    
    // Monitor total amount element (alternative)
    const totalAmountElement = document.querySelector('.total-amount');
    
    if (totalAmountElement) {
        const observer = new MutationObserver(() => {
            updateAllBumpVisibility();
        });
        
        observer.observe(totalAmountElement, {
            childList: true,
            characterData: true,
            subtree: true
        });
    }
    
    if (window.cartConfig.debugMode) {
        console.log('üí∞ Price monitoring setup complete');
    }
}

/**
 * Check bump conditions with multiple conditions & products support
 * @param {Object} bumpConfig - The order bump configuration
 * @returns {Object} - Detailed status of conditions
 */
function checkBumpConditionsDetailed(bumpConfig) {
    const result = {
        met: true,
        hasStarted: false,
        remainingTotal: 0,
        remainingProduct: 0,
        remainingTotalPrice: 0,
        remainingProductPrice: 0,
        productDetails: [],
        conditionResults: [] 
    };

    if (!bumpConfig.conditions) {
        return result;
    }

    // ========== NEW: Multiple Conditions Support ==========
    if (bumpConfig.conditions.multipleConditions && Array.isArray(bumpConfig.conditions.multipleConditions)) {
        const combineLogic = bumpConfig.conditions.combineLogic || 'all';
        
        // Check each condition
        const conditionResults = bumpConfig.conditions.multipleConditions.map((condition, index) => {
            const condResult = checkSingleCondition(condition);
            
            if (condResult.hasStarted) {
                result.hasStarted = true;
            }
            
            return {
                index,
                type: condition.type,
                met: condResult.met,
                hasStarted: condResult.hasStarted,
                details: condResult
            };
        });
        
        result.conditionResults = conditionResults;
        
        // Apply combine logic
        if (combineLogic === 'all') {
            // ALL conditions must be met (AND)
            const allMet = conditionResults.every(c => c.met);
            result.met = allMet;
            
            // Collect all remaining values for notification
            conditionResults.forEach(c => {
                if (!c.met) {
                    if (c.details.remainingTotal > 0) {
                        result.remainingTotal = Math.max(result.remainingTotal, c.details.remainingTotal);
                    }
                    if (c.details.remainingProduct > 0) {
                        result.remainingProduct = Math.max(result.remainingProduct, c.details.remainingProduct);
                    }
                    if (c.details.remainingTotalPrice > 0) {
                        result.remainingTotalPrice = Math.max(result.remainingTotalPrice, c.details.remainingTotalPrice);
                    }
                    if (c.details.remainingProductPrice > 0) {
                        result.remainingProductPrice = Math.max(result.remainingProductPrice, c.details.remainingProductPrice);
                    }
                    if (c.details.productDetails && c.details.productDetails.length > 0) {
                        result.productDetails.push(...c.details.productDetails);
                    }
                }
            });
        } else if (combineLogic === 'any') {
            // ANY condition is met (OR)
            const anyMet = conditionResults.some(c => c.met);
            result.met = anyMet;
            
            if (!anyMet) {
                // Get minimum remaining values from unmet conditions
                const unmetConditions = conditionResults.filter(c => !c.met);
                
                const totalValues = unmetConditions.map(c => c.details.remainingTotal).filter(v => v > 0);
                if (totalValues.length > 0) {
                    result.remainingTotal = Math.min(...totalValues);
                }
                
                const priceValues = unmetConditions.map(c => c.details.remainingTotalPrice).filter(v => v > 0);
                if (priceValues.length > 0) {
                    result.remainingTotalPrice = Math.min(...priceValues);
                }
                
                const productValues = unmetConditions.map(c => c.details.remainingProduct).filter(v => v > 0);
                if (productValues.length > 0) {
                    result.remainingProduct = Math.min(...productValues);
                }
                
                const productPriceValues = unmetConditions.map(c => c.details.remainingProductPrice).filter(v => v > 0);
                if (productPriceValues.length > 0) {
                    result.remainingProductPrice = Math.min(...productPriceValues);
                }
            }
        }
        
        return result;
    }

    // ========== BACKWARD COMPATIBILITY: Old Single Condition Format ==========
    if (!bumpConfig.conditions.type) {
        return result;
    }

    const singleResult = checkSingleCondition(bumpConfig.conditions);
    return singleResult;
}

/**
 * Check a single condition (extracted for reusability)
 * @param {Object} condition - Single condition object
 * @returns {Object} - Result for this condition
 */
function checkSingleCondition(condition) {
    const result = {
        met: true,
        hasStarted: false,
        remainingTotal: 0,
        remainingProduct: 0,
        remainingTotalPrice: 0,
        remainingProductPrice: 0,
        productDetails: []
    };

    const condType = condition.type;
    const productCombineLogic = condition.productCombineLogic || condition.combineLogic || 'all';

    // ========== QUANTITY-BASED CONDITIONS ==========
    
    if (condType === 'total') {
        const currentTotal = getTotalQuantity();
        const requiredTotal = condition.minTotalQuantity || 1;
        
        if (currentTotal > 0) {
            result.hasStarted = true;
        }

        if (currentTotal < requiredTotal) {
            result.met = false;
            result.remainingTotal = requiredTotal - currentTotal;
        }
    }

    if (condType === 'product') {
        // Multiple products support
        if (condition.requiredProducts && Array.isArray(condition.requiredProducts)) {
            const productResults = condition.requiredProducts.map(reqProduct => {
                const currentQty = getProductQuantity(reqProduct.id);
                const requiredQty = reqProduct.minQuantity || 1;
                const isMet = currentQty >= requiredQty;
                
                if (currentQty > 0) {
                    result.hasStarted = true;
                }
                
                return {
                    id: reqProduct.id,
                    currentQty,
                    requiredQty,
                    remaining: Math.max(0, requiredQty - currentQty),
                    met: isMet
                };
            });
            
            result.productDetails = productResults;
            
            if (productCombineLogic === 'all') {
                const allMet = productResults.every(p => p.met);
                if (!allMet) {
                    result.met = false;
                    result.remainingProduct = Math.max(...productResults.map(p => p.remaining));
                }
            } else if (productCombineLogic === 'any') {
                const anyMet = productResults.some(p => p.met);
                if (!anyMet) {
                    result.met = false;
                    result.remainingProduct = Math.min(...productResults.filter(p => p.remaining > 0).map(p => p.remaining));
                }
            }
        }
        // Single product (backward compatibility)
        else if (condition.requiredProduct) {
            const reqProduct = condition.requiredProduct;
            const currentQty = getProductQuantity(reqProduct.id);
            const requiredQty = reqProduct.minQuantity || 1;

            if (currentQty > 0) {
                result.hasStarted = true;
            }

            if (currentQty < requiredQty) {
                result.met = false;
                result.remainingProduct = requiredQty - currentQty;
            }
            
            result.productDetails = [{
                id: reqProduct.id,
                currentQty,
                requiredQty,
                remaining: Math.max(0, requiredQty - currentQty),
                met: currentQty >= requiredQty
            }];
        }
    }

    // ========== PRICE-BASED CONDITIONS ==========
    
    if (condType === 'price-total') {
        const currentTotalPrice = getTotalPrice();
        const requiredTotalPrice = condition.minTotalPrice || 0;
        
        if (currentTotalPrice > 0) {
            result.hasStarted = true;
        }

        if (currentTotalPrice < requiredTotalPrice) {
            result.met = false;
            result.remainingTotalPrice = requiredTotalPrice - currentTotalPrice;
        }
    }

    if (condType === 'price-product') {
        // Multiple products support
        if (condition.requiredProducts && Array.isArray(condition.requiredProducts)) {
            const productResults = condition.requiredProducts.map(reqProduct => {
                const currentPrice = getProductPrice(reqProduct.id);
                const requiredPrice = reqProduct.minPrice || 0;
                const isMet = currentPrice >= requiredPrice;
                
                if (currentPrice > 0) {
                    result.hasStarted = true;
                }
                
                return {
                    id: reqProduct.id,
                    currentPrice,
                    requiredPrice,
                    remaining: Math.max(0, requiredPrice - currentPrice),
                    met: isMet
                };
            });
            
            result.productDetails = productResults;
            
            if (productCombineLogic === 'all') {
                const allMet = productResults.every(p => p.met);
                if (!allMet) {
                    result.met = false;
                    result.remainingProductPrice = Math.max(...productResults.map(p => p.remaining));
                }
            } else if (productCombineLogic === 'any') {
                const anyMet = productResults.some(p => p.met);
                if (!anyMet) {
                    result.met = false;
                    result.remainingProductPrice = Math.min(...productResults.filter(p => p.remaining > 0).map(p => p.remaining));
                }
            }
        }
        // Single product (backward compatibility)
        else if (condition.requiredProduct) {
            const reqProduct = condition.requiredProduct;
            const currentProductPrice = getProductPrice(reqProduct.id);
            const requiredProductPrice = reqProduct.minPrice || 0;

            if (currentProductPrice > 0) {
                result.hasStarted = true;
            }

            if (currentProductPrice < requiredProductPrice) {
                result.met = false;
                result.remainingProductPrice = requiredProductPrice - currentProductPrice;
            }
            
            result.productDetails = [{
                id: reqProduct.id,
                currentPrice: currentProductPrice,
                requiredPrice: requiredProductPrice,
                remaining: Math.max(0, requiredProductPrice - currentProductPrice),
                met: currentProductPrice >= requiredProductPrice
            }];
        }
    }

    return result;
}

/**
 * Generate list-based message for multiple products
 * @param {string} combineLogic - 'all' or 'any'
 * @param {Object} bumpConfig - Bump configuration
 * @param {Array} productDetails - Array of product condition details
 * @returns {string} - Formatted HTML message with list
 */
function getMultipleProductsMessage(combineLogic, bumpConfig, productDetails) {
    const templates = window.cartConfig.notifications?.messages?.multipleProducts?.[combineLogic];
    
    if (!templates) {
        // Fallback to simple message
        return `Tambah produk yang diperlukan untuk unlock ${bumpConfig.productName}`;
    }
    
    // Get heading template
    let heading = templates.heading || 'Sila penuhi syarat berikut untuk unlock {bumpName}:';
    heading = heading.replace(/{bumpName}/g, `<strong>${bumpConfig.productName}</strong>`);
    
    // Get item template
    const itemTemplate = templates.itemTemplate || 
        'Perlukan {productQuantity} unit {productName}. Sekarang ada {currentProductQuantity} unit dalam cart, perlu tambah lagi {remainingProductQuantity} unit.';
    
    // Build list items
    const listItems = productDetails.map((detail, index) => {
        // Get product name
        const productData = getProductDataById(detail.id);
        const productName = productData?.name || `Produk ${detail.id}`;
        
        // Replace placeholders in item template
        let itemText = itemTemplate
            .replace(/{productQuantity}/g, `<strong>${detail.requiredQty}</strong>`)
            .replace(/{productName}/g, `<strong>${productName}</strong>`)
            .replace(/{currentProductQuantity}/g, `<strong>${detail.currentQty}</strong>`)
            .replace(/{remainingProductQuantity}/g, `<strong>${detail.remaining}</strong>`);
        
        return `<li>${itemText}</li>`;
    }).join('');
    
    // Combine heading + list
    return `
        <div class="multi-product-notification">
            <div class="notification-heading">${heading}</div>
            <ol class="notification-list">${listItems}</ol>
        </div>
    `;
}

/**
 * Get pending message with user-defined templates
 * @param {string} condType - Condition type
 * @param {Object} bumpConfig - Bump configuration
 * @param {Object} conditionStatus - Condition status
 * @returns {string} - Formatted message
 */
function getPendingMessage(condType, bumpConfig, conditionStatus) {
    const defaultMessages = window.cartConfig.notifications?.messages || {};
    const separators = window.cartConfig.notifications?.separators || {
        all: 'DAN',
        any: 'ATAU'
    };
    
    if (bumpConfig.conditions.multipleConditions) {
        const combineLogic = bumpConfig.conditions.combineLogic || 'all';
        const unmetConditions = conditionStatus.conditionResults?.filter(c => !c.met) || [];
        
        const multipleConfig = defaultMessages['multiple']?.[combineLogic];
        let customTemplate = null;
        
        if (typeof multipleConfig === 'string') {
            customTemplate = multipleConfig;
        } else if (multipleConfig && typeof multipleConfig === 'object') {
            customTemplate = multipleConfig.pending;
        }
        
        if (customTemplate) {
            // ‚úÖ FIX: Pass original condition to getConditionMessage
            const messages = unmetConditions.map(c => {
                // Get original condition from multipleConditions array
                const originalCondition = bumpConfig.conditions.multipleConditions[c.index];
                return getConditionMessage(c.type, c.details, bumpConfig, conditionStatus, originalCondition);
            }).filter(m => m);
            
            if (messages.length === 0) return `Unlock ${bumpConfig.productName}`;
            
            const wrappedConditions = messages.map(m => {
                if (m.includes('<div class="multi-product-notification">') || m.includes('<div class="single-condition-message">')) {
                    return m;
                }
                return `<strong>${m}</strong>`;
            });
            
            let conditionsText = '';
            const separator = separators[combineLogic] || 'DAN';
            
            if (wrappedConditions.length === 1) {
                conditionsText = wrappedConditions[0];
            } else if (wrappedConditions.length === 2) {
                conditionsText = wrappedConditions.join(`<div class="condition-separator">${separator}</div>`);
            } else {
                conditionsText = wrappedConditions.slice(0, -1).join(', ') + `<div class="condition-separator">${separator}</div>` + wrappedConditions[wrappedConditions.length - 1];
            }
            
            let finalMessage =  customTemplate
                .replace(/{conditions}/g, `<div class="conditions-text">${conditionsText}</div>`)
                .replace(/{bumpName}/g, `<strong>${bumpConfig.productName}</strong>`);

            return `<div class="multi-condition-wrapper">${finalMessage}</div>`;
        
        }
        
        return `Unlock ${bumpConfig.productName}`;
    }
    
    // Single condition (backward compatibility)
    const fallbackMessages = {
        'total': 'Tambah {remainingTotal} item lagi untuk unlock {bumpName}',
        'product': 'Tambah {remainingProduct} {productName} lagi untuk unlock {bumpName}',
        'price-total': 'Tambah lagi {remainingTotalPrice} untuk unlock {bumpName}',
        'price-product': 'Tambah lagi {remainingProductPrice} untuk {productName} untuk unlock {bumpName}'
    };
    
    let template = defaultMessages[condType]?.pending || fallbackMessages[condType];
    
    if (!template) {
        return `Unlock ${bumpConfig.productName}`;
    }

    const typesWithMultipleProducts = ['product', 'price-product'];
    if (typesWithMultipleProducts.includes(condType)) {
        const hasMultipleProducts = conditionStatus.productDetails && conditionStatus.productDetails.length > 1;
        
        if (hasMultipleProducts) {
            return getConditionMessage(condType, conditionStatus, bumpConfig, conditionStatus);
        }
    }
    
    return replacePlaceholdersInMessage(template, bumpConfig, conditionStatus);
}

/**
 * Get message for a single condition
 * @param {string} condType - Condition type
 * @param {Object} details - Condition details
 * @param {Object} bumpConfig - Bump configuration
 * @param {Object} fullConditionStatus - OPTIONAL: Full condition status for 'both' types
 * @param {Object} originalCondition - NEW: Original condition object to identify correct combineLogic
 * @returns {string} - Formatted message
 */
function getConditionMessage(condType, details, bumpConfig, fullConditionStatus = null, originalCondition = null) {
    switch(condType) {
        case 'total':
            return `${details.remainingTotal} item lagi`;
            
        case 'price-total':
            return `${formatPrice(details.remainingTotalPrice)} lagi`;
            
        case 'product': {
            // Check if multiple products
            if (details.productDetails && details.productDetails.length > 1) {
                let combineLogic = 'all';
                
                if (originalCondition && originalCondition.productCombineLogic) {
                    combineLogic = originalCondition.productCombineLogic;
                }
                else if (bumpConfig.conditions.multipleConditions) {
                    const matchingCondition = bumpConfig.conditions.multipleConditions.find(c => 
                        c.type === 'product' && c.requiredProducts && c.requiredProducts.length > 1
                    );
                    if (matchingCondition) {
                        combineLogic = matchingCondition.productCombineLogic || matchingCondition.combineLogic || 'all';
                    }
                } else if (bumpConfig.conditions.requiredProducts && bumpConfig.conditions.requiredProducts.length > 1) {
                    combineLogic = bumpConfig.conditions.productCombineLogic || bumpConfig.conditions.combineLogic || 'all';
                }
                
                return getMultipleProductsMessage(combineLogic, bumpConfig, details.productDetails);
            }
            
            // ‚úÖ Single product - wrap dalam div untuk new line
            let productName = 'produk';
            
            if (bumpConfig.conditions.multipleConditions) {
                const matchingCondition = bumpConfig.conditions.multipleConditions.find(c => {
                    if (c.type === 'product' && c.requiredProduct) {
                        return details.productDetails?.some(pd => pd.id === c.requiredProduct.id);
                    }
                    return false;
                });
                
                if (matchingCondition?.requiredProduct) {
                    const productData = getProductDataById(matchingCondition.requiredProduct.id);
                    productName = productData?.name || `Produk ${matchingCondition.requiredProduct.id}`;
                }
            } else if (bumpConfig.conditions.requiredProduct) {
                const productData = getProductDataById(bumpConfig.conditions.requiredProduct.id);
                productName = productData?.name || `Produk ${bumpConfig.conditions.requiredProduct.id}`;
            }
            
            const defaultMessages = window.cartConfig.notifications?.messages || {};
            const template = defaultMessages['product']?.pending || 'Tambah {remainingProduct} {productName} lagi untuk unlock {bumpName}';
            
            const message = template
                // New standardized placeholders
                .replace(/{productQuantity}/g, `<strong>${productDetail.requiredQty || 1}</strong>`)
                .replace(/{currentProductQuantity}/g, `<strong>${productDetail.currentQty || 0}</strong>`)
                .replace(/{remainingProductQuantity}/g, `<strong>${details.remainingProduct}</strong>`)
                .replace(/{productName}/g, `<strong>${productName}</strong>`)
                .replace(/{bumpName}/g, `<strong>${bumpConfig.productName}</strong>`);
            
            // ‚úÖ Wrap dalam div seperti multi-product-notification untuk consistency
            return `<div class="single-condition-message">${message}</div>`;
        }
            
        case 'price-product': {
            // Check if multiple products
            if (details.productDetails && details.productDetails.length > 1) {
                let combineLogic = 'all';
                
                if (originalCondition && originalCondition.productCombineLogic) {
                    combineLogic = originalCondition.productCombineLogic;
                }
                else if (bumpConfig.conditions.multipleConditions) {
                    const matchingCondition = bumpConfig.conditions.multipleConditions.find(c => 
                        c.type === 'price-product' && c.requiredProducts && c.requiredProducts.length > 1
                    );
                    if (matchingCondition) {
                        combineLogic = matchingCondition.productCombineLogic || matchingCondition.combineLogic || 'all';
                    }
                } else if (bumpConfig.conditions.requiredProducts && bumpConfig.conditions.requiredProducts.length > 1) {
                    combineLogic = bumpConfig.conditions.productCombineLogic || bumpConfig.conditions.combineLogic || 'all';
                }
                
                return getMultipleProductsPriceMessage(combineLogic, bumpConfig, details.productDetails);
            }
            
            // ‚úÖ Single product - wrap dalam div untuk new line
            let productName = 'produk';
            
            if (bumpConfig.conditions.multipleConditions) {
                const matchingCondition = bumpConfig.conditions.multipleConditions.find(c => {
                    if (c.type === 'price-product' && c.requiredProduct) {
                        return details.productDetails?.some(pd => pd.id === c.requiredProduct.id);
                    }
                    return false;
                });
                
                if (matchingCondition?.requiredProduct) {
                    const productData = getProductDataById(matchingCondition.requiredProduct.id);
                    productName = productData?.name || `Produk ${matchingCondition.requiredProduct.id}`;
                }
            } else if (bumpConfig.conditions.requiredProduct) {
                const productData = getProductDataById(bumpConfig.conditions.requiredProduct.id);
                productName = productData?.name || `Produk ${bumpConfig.conditions.requiredProduct.id}`;
            }
            
            const defaultMessages = window.cartConfig.notifications?.messages || {};
            const template = defaultMessages['price-product']?.pending || 'Tambah lagi {remainingProductPrice} untuk {productName} untuk unlock {bumpName}';
            
            const message = template
                // New standardized placeholders
                .replace(/{productPrice}/g, `<strong>${formatPrice(productDetail.requiredPrice || 0)}</strong>`)
                .replace(/{currentProductPrice}/g, `<strong>${formatPrice(productDetail.currentPrice || 0)}</strong>`)
                .replace(/{remainingProductPrice}/g, `<strong>${formatPrice(details.remainingProductPrice)}</strong>`)
                .replace(/{productName}/g, `<strong>${productName}</strong>`)
                .replace(/{bumpName}/g, `<strong>${bumpConfig.productName}</strong>`);
            
            // ‚úÖ Wrap dalam div seperti multi-product-notification untuk consistency
            return `<div class="single-condition-message">${message}</div>`;
        }
            
        default:
            return '';
    }
}

/**
 * Generate list-based message for multiple products (PRICE version)
 * @param {string} combineLogic - 'all' or 'any'
 * @param {Object} bumpConfig - Bump configuration
 * @param {Array} productDetails - Array of product condition details
 * @returns {string} - Formatted HTML message with list
 */
function getMultipleProductsPriceMessage(combineLogic, bumpConfig, productDetails) {
    const templates = window.cartConfig.notifications?.messages?.multipleProducts?.[combineLogic];
    
    if (!templates) {
        return `Tambah harga produk yang diperlukan untuk unlock ${bumpConfig.productName}`;
    }
    
    // Get heading template (use price-specific if available)
    let heading = templates.priceHeading || templates.heading || 'Sila penuhi syarat berikut untuk unlock {bumpName}:';
    heading = heading.replace(/{bumpName}/g, `<strong>${bumpConfig.productName}</strong>`);
    
    // Get item template (use price-specific if available)
    const itemTemplate = templates.priceItemTemplate || 
        'Perlukan {productPrice} untuk {productName}. Sekarang ada {currentProductPrice} dalam cart, perlu tambah lagi {remainingProductPrice}.';
    
    // Build list items
    const listItems = productDetails.map((detail, index) => {
        // Get product name
        const productData = getProductDataById(detail.id);
        const productName = productData?.name || `Produk ${detail.id}`;
        
        // Replace placeholders in item template
        let itemText = itemTemplate
            .replace(/{productPrice}/g, `<strong>${formatPrice(detail.requiredPrice)}</strong>`)
            .replace(/{productName}/g, `<strong>${productName}</strong>`)
            .replace(/{currentProductPrice}/g, `<strong>${formatPrice(detail.currentPrice)}</strong>`)
            .replace(/{remainingProductPrice}/g, `<strong>${formatPrice(detail.remaining)}</strong>`);
        
        return `<li>${itemText}</li>`;
    }).join('');
    
    // Combine heading + list
    return `
        <div class="multi-product-notification">
            <div class="notification-heading">${heading}</div>
            <ol class="notification-list">${listItems}</ol>
        </div>
    `;
}

/**
 * Replace placeholders in message template
 */
function replacePlaceholdersInMessage(template, bumpConfig, conditionStatus) {
    let productName = '';
    
    if (bumpConfig.conditions.requiredProducts && Array.isArray(bumpConfig.conditions.requiredProducts)) {
        const productNames = bumpConfig.conditions.requiredProducts.map(reqProduct => {
            const productData = getProductDataById(reqProduct.id);
            return productData?.name || `Produk ${reqProduct.id}`;
        });
        
        if (productNames.length === 1) {
            productName = productNames[0];
        } else if (productNames.length === 2) {
            productName = productNames.join(' & ');
        } else {
            productName = productNames.slice(0, -1).join(', ') + ' & ' + productNames[productNames.length - 1];
        }
    } else if (bumpConfig.conditions.requiredProduct) {
        const productData = getProductDataById(bumpConfig.conditions.requiredProduct.id);
        productName = productData?.name || 'produk';
    }
    
    let message = template;

    // Core placeholders
    message = message.replace(/{bumpName}/g, `<strong>${bumpConfig.productName || 'order bump'}</strong>`);
    message = message.replace(/{productName}/g, `<strong>${productName}</strong>`);
    
    // Quantity placeholders
    message = message.replace(/{remainingTotal}/g, `<strong>${conditionStatus.remainingTotal || 0}</strong>`);
    message = message.replace(/{remainingProduct}/g, `<strong>${conditionStatus.remainingProduct || 0}</strong>`);
    
    // Price placeholders
    message = message.replace(/{remainingTotalPrice}/g, `<strong>${formatPrice(conditionStatus.remainingTotalPrice || 0)}</strong>`);
    message = message.replace(/{remainingProductPrice}/g, `<strong>${formatPrice(conditionStatus.remainingProductPrice || 0)}</strong>`);
    
    return message;
}

/**
 * Get success message with user-defined templates (UPDATED VERSION)
 * Supports multiple conditions with combineLogic
 * 
 * @param {string} condType - Condition type
 * @param {string} bumpName - Order bump name
 * @param {Object} bumpConfig - Full bump configuration (NEW)
 * @returns {string} - Formatted message
 */
function getSuccessMessage(condType, bumpName, bumpConfig) {
    const defaultMessages = window.cartConfig.notifications?.messages || {};
    
    // ========== MULTIPLE CONDITIONS SUPPORT ==========
    if (bumpConfig && bumpConfig.conditions && bumpConfig.conditions.multipleConditions) {
        const combineLogic = bumpConfig.conditions.combineLogic || 'all';
        
        // Support both flat string AND nested object
        const multipleConfig = defaultMessages['multiple']?.[combineLogic];
        let multipleSuccessMsg = null;
        
        if (typeof multipleConfig === 'object' && multipleConfig.success) {
            // Nested object (new format)
            multipleSuccessMsg = multipleConfig.success;
        }
        
        if (multipleSuccessMsg) {
            // Replace {bumpName} placeholder
            return multipleSuccessMsg.replace(/{bumpName}/g, `<strong>${bumpName}</strong>`);
        }
        
        // Fallback to generic success message
        const fallbackMsg = defaultMessages['multiple']?.success || 
                           'Tahniah! Anda layak untuk <strong>{bumpName}</strong> pada harga diskaun';
        
        return fallbackMsg.replace(/{bumpName}/g, `<strong>${bumpName}</strong>`);
    }
    
    // ========== SINGLE CONDITION (BACKWARD COMPATIBILITY) ==========
    const fallbackMessage = 'Tahniah! Anda layak untuk <strong>{bumpName}</strong> pada harga diskaun';
    
    // Get user-defined message or fallback
    let template = defaultMessages[condType]?.success || fallbackMessage;
    
    // Replace placeholders
    return template.replace(/{bumpName}/g, `<strong>${bumpName}</strong>`);
}

/**
 * Create or update notification for order bump conditions
 * @param {number} bumpIndex - Index of the order bump
 * @param {Object} conditionStatus - Status of conditions (met, remaining counts, etc)
 */
function updateBumpNotification(bumpIndex, conditionStatus) {
    if (!window.cartConfig.notifications.enabled) return;

    const bumpConfig = window.cartConfig.orderBumps[bumpIndex];
    
    if (!bumpConfig || !bumpConfig.conditions) return;
    
    // Check if it's a valid condition config (either has type OR multipleConditions)
    const hasValidConditions = bumpConfig.conditions.type || 
                               (bumpConfig.conditions.multipleConditions && 
                                Array.isArray(bumpConfig.conditions.multipleConditions));
    
    if (!hasValidConditions) return;

    const notificationId = `bump-notification-${bumpIndex}`;
    let notification = document.getElementById(notificationId);
    const bumpContainer = document.querySelector(`.order-bump-container[data-bump-index="${bumpIndex}"]`);

    // If conditions are met
    if (conditionStatus.met) {
        if (notification) {
            if (window.cartConfig.notifications.showSuccessMessage) {
                
                const message = getSuccessMessage(bumpConfig.conditions.type, bumpConfig.productName, bumpConfig);

                notification.className = 'order-bump-notification success';
                notification.innerHTML = `
                    <div class="order-bump-notification-content">
                        <div class="order-bump-notification-icon">
                            <i class="fa fa-check"></i>
                        </div>
                        <div class="order-bump-notification-text">
                            <div class="order-bump-notification-message">${message}</div>
                        </div>
                    </div>
                `;

                setTimeout(() => {
                    if (notification && notification.parentNode) {
                        notification.style.animation = 'slideInNotification 0.3s ease reverse';
                        setTimeout(() => {
                            if (notification && notification.parentNode) {
                                notification.remove();
                            }
                        }, 300);
                    }
                }, 5000);
            } else {
                if (notification && notification.parentNode) {
                    notification.remove();
                }
            }
        }
        return;
    }

    // If conditions are not met and user has started ordering
    if (!conditionStatus.met && conditionStatus.hasStarted) {
        // ‚úÖ Use updated getPendingMessage with user-defined template
        const message = getPendingMessage(bumpConfig.conditions.type, bumpConfig, conditionStatus);

        // Create or update notification
        if (!notification) {
            notification = document.createElement('div');
            notification.id = notificationId;
            notification.className = 'order-bump-notification';

            if (bumpContainer) {
                bumpContainer.insertAdjacentElement('beforebegin', notification);
            } else {
                const { targetElement, insertMethod } = getOrderBumpInsertTarget();
                if (targetElement) {
                    targetElement.insertAdjacentElement(insertMethod === 'beforebegin' ? 'beforebegin' : 'afterend', notification);
                }
            }
        }

        notification.innerHTML = `
            <div class="order-bump-notification-content">
                <div class="order-bump-notification-text">
                    <div class="order-bump-notification-message">${message}</div>
                </div>
            </div>
        `;
    } else {
        if (notification && notification.parentNode) {
            notification.remove();
        }
    }
}

function getProductDataById(productId) {
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (!productRow) {
        console.warn(`Product with ID ${productId} not found`);
        return null;
    }
    
    const productNameCell = productRow.querySelector('td:first-child');
    const productName = productNameCell ? productNameCell.textContent.trim() : '';
    
    if (window.cartConfig.debugMode) {
        console.log(`üì¶ Product ${productId} found:`, productName);
    }
    
    return {
        id: productId,
        name: productName,
    };
}

function formatPrice(price) {
    const formatted = price.toFixed(window.cartConfig.currency.decimalPlaces);
    if (window.cartConfig.currency.position === 'before') {
        return `${window.cartConfig.currency.symbol}${formatted}`;
    }
    return `${formatted}${window.cartConfig.currency.symbol}`;
}

function calculateSavings(originalPrice, discountedPrice) {
    return originalPrice - discountedPrice;
}

function replacePlaceholders(template, bumpConfig) {
    const savings = calculateSavings(bumpConfig.originalPrice, bumpConfig.discountedPrice);
    const savingsText = bumpConfig.savingsText.replace('{amount}', formatPrice(savings));
    
    // Mapping placeholders to their CSS classes
    const placeholderMap = {
        '{productName}': {
            value: bumpConfig.productName,
            class: 'bump-product-name'
        },
        '{oldPrice}': {
            value: formatPrice(bumpConfig.originalPrice),
            class: 'bump-price-old'
        },
        '{newPrice}': {
            value: formatPrice(bumpConfig.discountedPrice),
            class: 'bump-price-new'
        },
        '{savings}': {
            value: savingsText,
            class: 'bump-save'
        }
    };
    
    // Replace each placeholder with wrapped HTML
    let result = template;
    
    Object.entries(placeholderMap).forEach(([placeholder, config]) => {
        // Create regex to find placeholder (case insensitive for safety)
        const regex = new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'gi');
        
        // Replace with wrapped span
        result = result.replace(regex, `<span class="${config.class}">${config.value}</span>`);
    });
    
    return result;
}

function processBumpConfig(bumpConfig) {
    if (bumpConfig.productId) {
        const productData = getProductDataById(bumpConfig.productId);
        
        if (productData) {
            if (!bumpConfig.productName) {
                bumpConfig.productName = productData.name;
            }

            if (productData.price && !bumpConfig.discountedPrice) {
                bumpConfig.discountedPrice = productData.price;
            }
        }
    }
    
    if (!bumpConfig.productName) {
        console.error('Order bump missing productName:', bumpConfig);
        return null;
    }
    
    if (!bumpConfig.discountedPrice) {
        console.error('Order bump missing discountedPrice:', bumpConfig);
        return null;
    }
    
    return bumpConfig;
}

function syncOrderBumpToProduct(bumpIndex, quantity) {
    const bumpConfig = window.cartConfig.orderBumps[bumpIndex];
    
    if (!bumpConfig || !bumpConfig.productId) {
        console.warn(`Order bump ${bumpIndex} tidak mempunyai productId`);
        return false;
    }
    
    const productRow = document.querySelector(`.product[data-id="${bumpConfig.productId}"]`);
    
    if (!productRow) {
        console.warn(`Product dengan ID ${bumpConfig.productId} tidak dijumpai`);
        return false;
    }
    
    const selectElement = productRow.querySelector('select.quantity');
    
    if (selectElement) {
        // Prevent infinite loop
        selectElement.dataset.fromBump = 'true';
        
        if (typeof $ !== 'undefined' && $.fn.select2) {

            $(selectElement).val(quantity.toString());
            $(selectElement).trigger('change.select2');
            
            // Trigger input event
            setTimeout(() => {
                const inputEvent = new Event('input', { bubbles: true });
                selectElement.dispatchEvent(inputEvent);
            }, 50);
            
        } else {
            selectElement.value = quantity.toString();
            selectElement.dispatchEvent(new Event('change', { bubbles: true }));
            selectElement.dispatchEvent(new Event('input', { bubbles: true }));
        }
        
        if (window.cartConfig.debugMode) {
            console.log(`‚úÖ Product ${bumpConfig.productId} (${bumpConfig.productName}) quantity set to: ${quantity}`);
        }
        
        return true;
    }
    
    return false;
}

function clearProductQuantity(bumpIndex) {
    return syncOrderBumpToProduct(bumpIndex, 0);
}

function hideProductInTable(productId) {
    // Cari product row dengan data-id yang sepadan
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (productRow) {
        // Set visibility collapse dan opacity 0
        productRow.style.visibility = 'collapse';
        productRow.style.opacity = '0';
        
        if (window.cartConfig.debugMode) {
            console.log(`üôà Product ${productId} hidden from table`);
        }
    }
}

function hideOrderBumpProducts() {
    // Loop semua order bumps yang enabled dan ada productId
    window.cartConfig.orderBumps.forEach((bump, index) => {
        if (bump.enabled && bump.productId) {
            hideProductInTable(bump.productId);
        }
    });
}

function showProductAsOrderBump(productId, quantity) {
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (productRow) {
        // Show product row
        productRow.style.visibility = 'visible';
        productRow.style.opacity = '1';
        
        // Tambah order bump badge kalau belum ada
        const productNameCell = productRow.querySelector('td:first-child');
        if (productNameCell && !productNameCell.querySelector('.order-bump-badge-table')) {
            const badge = document.createElement('span');
            badge.className = 'order-bump-badge-table';
            badge.textContent = window.cartConfig.bumpsBadge.text;
            productNameCell.insertBefore(badge, productNameCell.firstChild);
            
            // Add space after badge
            productNameCell.insertBefore(document.createTextNode(' '), badge.nextSibling);
        }
        
        // Disable quantity selector
        const quantitySelect = productRow.querySelector('.quantity');
        if (quantitySelect) {
            quantitySelect.disabled = true;
            quantitySelect.style.opacity = '0.6';
            quantitySelect.style.cursor = 'not-allowed';
        }
        
        if (window.cartConfig.debugMode) {
            console.log(`üëÅÔ∏è Product ${productId} shown as Order Bump`);
        }
    }
}

function resetProductInTable(productId) {
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (productRow) {
        // Hide product row again
        productRow.style.visibility = 'collapse';
        productRow.style.opacity = '0';
        
        // Remove order bump badge
        const badge = productRow.querySelector('.order-bump-badge-table');
        if (badge) {
            badge.remove();
            // Remove space after badge if exists
            const nextNode = productRow.querySelector('td:first-child').childNodes[0];
            if (nextNode && nextNode.nodeType === 3 && nextNode.textContent.trim() === '') {
                nextNode.remove();
            }
        }
        
        // Enable quantity selector dan reset ke 0
        const quantitySelect = productRow.querySelector('.quantity');
        if (quantitySelect) {
            quantitySelect.disabled = false;
            quantitySelect.style.opacity = '1';
            quantitySelect.style.cursor = 'pointer';
        }
        
        if (window.cartConfig.debugMode) {
            console.log(`üîÑ Product ${productId} reset and hidden`);
        }
    }
}

/**
 * Get the target element where order bumps should be inserted
 * @returns {Object} - Object containing targetElement and insertMethod
 */
function getOrderBumpInsertTarget() {
    const location = window.cartConfig.orderBumpsLocation;
    let targetElement = null;
    let insertMethod = 'beforebegin';
    
    switch(location.position) {
        case 'before-payment':
            targetElement = document.getElementById('payment-section');
            insertMethod = 'beforebegin';
            break;
            
        case 'after-products':
            targetElement = document.querySelector('.table.table-condensed.purchase_details:not(.table-hover)');
            insertMethod = 'afterend';
            break;
            
        case 'before-customer':
            targetElement = document.querySelector('h2.section-header'); // First section header (BUTIRAN PELANGGAN)
            insertMethod = 'beforebegin';
            break;
            
        case 'custom':
            targetElement = document.querySelector(location.customSelector);
            insertMethod = location.insertMethod || 'afterend';
            break;
            
        default:
            // Fallback to before payment
            targetElement = document.getElementById('payment-section');
            insertMethod = 'beforebegin';
    }
    
    if (!targetElement) {
        console.error(`‚ùå Order bump target element not found for position: ${location.position}`);
        // Try fallback to payment section
        targetElement = document.getElementById('payment-section');
        insertMethod = 'beforebegin';
    }
    
    if (window.cartConfig.debugMode) {
        console.log(`üìç Order bump insert target:`, {
            position: location.position,
            element: targetElement,
            method: insertMethod
        });
    }
    
    return { targetElement, insertMethod };
}

/**
 * Get quantity for a specific product
 * @param {number} productId - The product ID to check
 * @returns {number} - Current quantity of the product
 */
function getProductQuantity(productId) {
    const productRow = document.querySelector(`.product[data-id="${productId}"]`);
    
    if (!productRow) {
        return 0;
    }
    
    const selectElement = productRow.querySelector('select.quantity');
    
    if (selectElement) {
        return parseInt(selectElement.value) || 0;
    }
    
    return 0;
}

/**
 * Get total quantity from cart
 * @returns {number} - Total quantity in cart
 */
function getTotalQuantity() {
    const totalQuantityElement = document.querySelector('.total-quantity');
    
    if (totalQuantityElement) {
        return parseInt(totalQuantityElement.textContent) || 0;
    }
    
    return 0;
}

/**
 * Check if order bump conditions are met
 * @param {Object} bumpConfig - The order bump configuration
 * @returns {boolean} - True if conditions are met, false otherwise
 */
function checkBumpConditions(bumpConfig) {
    const detailed = checkBumpConditionsDetailed(bumpConfig);
    return detailed.met;
}

/**
 * Update visibility for a single order bump
 * @param {number} bumpIndex - Index of the order bump in window.cartConfig.orderBumps
 */
function updateBumpVisibility(bumpIndex) {
    const bumpConfig = window.cartConfig.orderBumps[bumpIndex];
    
    if (!bumpConfig || !bumpConfig.enabled) {
        return;
    }
    
    const bumpContainer = document.querySelector(`.order-bump-container[data-bump-index="${bumpIndex}"]`);
    
    if (!bumpContainer) {
        return;
    }
    
    // Get detailed condition status
    const conditionStatus = checkBumpConditionsDetailed(bumpConfig);
    const shouldShow = conditionStatus.met;
    const hasStarted = conditionStatus.hasStarted;
    
    // Update notification
    updateBumpNotification(bumpIndex, conditionStatus);
    
    // Get checkbox reference
    const checkbox = bumpContainer.querySelector('.order-bump-input');
    const quantityWrapper = bumpContainer.querySelector('.order-bump-quantity-wrapper');
    
    // Show bump bila user dah mula order
    if (hasStarted || shouldShow) {
        bumpContainer.style.display = 'block';
        
        if (!shouldShow) {
            // Conditions not met - DISABLE bump
            bumpContainer.classList.add('disabled');
            
            if (checkbox) {
                checkbox.disabled = true;
                
                // Uncheck dan trigger event untuk clear product dari table
                if (checkbox.checked) {
                    checkbox.checked = false;
                    // Trigger change event manually
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }
            
            // Hide quantity wrapper jika ada
            if (quantityWrapper) {
                quantityWrapper.style.display = 'none';
            }
            
            if (window.cartConfig.debugMode) {
                console.log(`√∞≈∏"' Order bump ${bumpIndex} shown but DISABLED (conditions not met)`);
            }
        } else {
            // Conditions met - ENABLE bump
            bumpContainer.classList.remove('disabled');
            if (checkbox) {
                checkbox.disabled = false;
            }
            
            if (window.cartConfig.debugMode) {
                console.log(`Order bump ${bumpIndex} ENABLED (conditions met)`);
            }
        }
    } else {
        // User belum mula order - HIDE bump sepenuhnya
        bumpContainer.style.display = 'none';
        
        // Uncheck dan trigger event untuk clear product dari table
        if (checkbox && checkbox.checked) {
            checkbox.checked = false;
            // Trigger change event manually
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        
        if (window.cartConfig.debugMode) {
            console.log(`Order bump ${bumpIndex} hidden (user hasn't started ordering)`);
        }
    }
}

/**
 * Update visibility for all order bumps
 */
function updateAllBumpVisibility() {
    window.cartConfig.orderBumps.forEach((bump, index) => {
        if (bump.enabled) {
            updateBumpVisibility(index);
        }
    });
}

/**
 * Setup monitoring for quantity changes
 * Monitors both product quantities and total quantity
 */
function setupQuantityMonitoring() {
    // Monitor semua product quantity selectors
    const allQuantitySelectors = document.querySelectorAll('.product select.quantity');
    
    allQuantitySelectors.forEach(selector => {
        // Monitor changes via select2 if available
        if (typeof $ !== 'undefined' && $.fn.select2) {
            $(selector).on('change.select2', function() {
                // Delay sikit untuk pastikan value dah update
                setTimeout(() => {
                    updateAllBumpVisibility();
                }, 100);
            });
        }
        
        // Fallback to native change event
        selector.addEventListener('change', function() {
            setTimeout(() => {
                updateAllBumpVisibility();
            }, 100);
        });
        
        selector.addEventListener('input', function() {
            setTimeout(() => {
                updateAllBumpVisibility();
            }, 100);
        });
    });
    
    // Monitor total quantity changes
    const totalQuantityElement = document.querySelector('.total-quantity');
    
    if (totalQuantityElement) {
        const observer = new MutationObserver(() => {
            updateAllBumpVisibility();
        });
        
        observer.observe(totalQuantityElement, {
            childList: true,
            characterData: true,
            subtree: true
        });

        setupPriceMonitoring();
        
        if (window.cartConfig.debugMode) {
            console.log('üëÄ Quantity monitoring setup complete');
        }
    }
}

// Separate function untuk setup listeners
function setupOrderBumpListeners() {
    document.querySelectorAll('.order-bump-input').forEach(checkbox => {
        const index = parseInt(checkbox.getAttribute('data-bump-index'));
        const bumpConfig = processBumpConfig(window.cartConfig.orderBumps[index]);
        if (!bumpConfig) return;
        
        const bumpId = `order-bump-${index}`;
        const quantityWrapper = document.getElementById(`${bumpId}-quantity-wrapper`);
        const qtyInput = document.getElementById(`${bumpId}-qty-input`);
        const bumpTotalPrice = document.getElementById(`${bumpId}-total-price`);
        const minusBtn = document.querySelector(`.qty-minus[data-bump-index="${index}"]`);
        const plusBtn = document.querySelector(`.qty-plus[data-bump-index="${index}"]`);
        
        function updateBumpTotal() {
            const quantity = parseInt(qtyInput.value) || 1;
            const total = bumpConfig.discountedPrice * quantity;
            bumpTotalPrice.textContent = formatPrice(total);
            
            if (checkbox.checked) {
                syncOrderBumpToProduct(index, quantity);
            }
            
            if (window.cartConfig.debugMode) {
                console.log(`Order bump ${index} total: ${formatPrice(total)}`);
            }
        }

        function updateQuantityButtons() {
            const currentValue = parseInt(qtyInput.value) || 1;
            if (minusBtn) {
                minusBtn.disabled = (currentValue <= bumpConfig.minQuantity);
            }
            if (plusBtn) {
                plusBtn.disabled = (currentValue >= bumpConfig.maxQuantity);
            }
        }

        // Set initial button states
        updateQuantityButtons();
        
        checkbox.addEventListener('change', function() {
            if (this.checked) {
                quantityWrapper.style.display = 'flex';
                const initialQty = parseInt(qtyInput.value) || bumpConfig.defaultQuantity;
                
                setTimeout(() => {
                    syncOrderBumpToProduct(index, initialQty);
                }, 100);
                
                updateBumpTotal();

                // Show product dalam table dengan quantity dari order bump
                if (bumpConfig.productId) {
                    const currentQty = parseInt(qtyInput.value) || bumpConfig.defaultQuantity;
                    showProductAsOrderBump(bumpConfig.productId, currentQty);
                }
                
                if (window.cartConfig.debugMode) {
                    console.log(`‚úÖ Order bump ${index} selected:`, bumpConfig.productName);
                }
            } else {
                quantityWrapper.style.display = 'none';
                clearProductQuantity(index);

                // Hide product dalam table semula
                if (bumpConfig.productId) {
                    resetProductInTable(bumpConfig.productId);
                }
                
                if (window.cartConfig.debugMode) {
                    console.log(`‚ùå Order bump ${index} deselected`);
                }
            }
        });
        
        if (minusBtn) {
            minusBtn.addEventListener('click', function(e) {
                e.preventDefault();
                let currentValue = parseInt(qtyInput.value) || 1;
                if (currentValue > bumpConfig.minQuantity) {
                    qtyInput.value = currentValue - 1;
                    updateBumpTotal();
                    updateQuantityButtons();
                }
            });
        }
        
        if (plusBtn) {
            plusBtn.addEventListener('click', function(e) {
                e.preventDefault();
                let currentValue = parseInt(qtyInput.value) || 1;
                if (currentValue < bumpConfig.maxQuantity) {
                    qtyInput.value = currentValue + 1;
                    updateBumpTotal();
                    updateQuantityButtons();
                }
            });
        }
        
        if (qtyInput) {
            qtyInput.addEventListener('change', function() {
                let value = parseInt(this.value) || 1;
                
                if (value < bumpConfig.minQuantity) value = bumpConfig.minQuantity;
                if (value > bumpConfig.maxQuantity) value = bumpConfig.maxQuantity;
                
                this.value = value;
                updateBumpTotal();
                updateQuantityButtons();
            });
        }
    });
}

function init() {
    // Check if config exists
    if (!window.cartConfig) {
        console.error('cartConfig not found! Please define window.cartConfig before loading this script.');
        return;
    }

    injectCartHTML();

    const cartForm = document.getElementById('form');
    const toggleBtn = document.getElementById('cart-toggle-btn');
    const cartQty = document.getElementById('cartQty');
    const formOverlay = document.getElementById('form-overlay');

    toggleBtn.addEventListener('click', function () {
        cartForm.classList.toggle('active');
        toggleBtn.classList.toggle('active');
        formOverlay.classList.toggle('active');
    });

    formOverlay.addEventListener('click', function() {
        cartForm.classList.remove('active');
        toggleBtn.classList.remove('active');
        formOverlay.classList.remove('active');
    });

    function updateCartCount() {
        const totalQuantityElement = document.querySelector('.total-quantity');
        if (totalQuantityElement) {
            const totalCount = parseInt(totalQuantityElement.textContent) || 0;
            cartQty.setAttribute('data-count', totalCount);
        }
    }

    const totalQuantityElement = document.querySelector('.total-quantity');
    if (totalQuantityElement) {
        updateCartCount();
        const observer = new MutationObserver(updateCartCount);
        observer.observe(totalQuantityElement, {
            childList: true,
            characterData: true,
            subtree: true
        });
    }

    function updateTotalAmount() {
        const totalAmountElement = document.querySelector('.total-amount');
        const cartTotalDisplay = document.querySelector('.cart-total');
        
        if (totalAmountElement && cartTotalDisplay) {
            const totalAmount = totalAmountElement.textContent.trim();
            cartTotalDisplay.textContent = totalAmount;
        }
    }

    const totalAmountElement = document.querySelector('.total-amount');
    if (totalAmountElement) {
        updateTotalAmount();
        const amountObserver = new MutationObserver(updateTotalAmount);
        amountObserver.observe(totalAmountElement, { 
            childList: true, 
            characterData: true, 
            subtree: true 
        });
    }

    document.querySelectorAll('input[type="radio"]').forEach(radio => {
        const customDiv = document.createElement('div');
        customDiv.className = 'checkbox-custom';
        radio.insertAdjacentElement('afterend', customDiv);
    });
}

// ========== INITIALIZE CART ==========
document.addEventListener('DOMContentLoaded', function() {
    init();
    
    // Set toggle button text
    const toggleBtnText = document.querySelector('.toggle-btn-txt');
    if (toggleBtnText) {
        toggleBtnText.textContent = window.cartConfig.cartButton.text;
    }
    
    // Set currency symbol in cart total
    const cartTotalElement = document.querySelector('.cart-total');
    if (cartTotalElement && window.cartConfig.currency.position === 'before') {
        cartTotalElement.style.setProperty('--currency-symbol', `"${window.cartConfig.currency.symbol}"`);
    } else if (cartTotalElement && window.cartConfig.currency.position === 'after') {
        const style = document.createElement('style');
        style.textContent = `
            .left-section .cart-total::before { content: none !important; }
            .left-section .cart-total::after { content: "${window.cartConfig.currency.symbol}"; margin-left: 2px; }
        `;
        document.head.appendChild(style);
    }
    
    const cartForm = document.getElementById('form');
    
    if (cartForm && !cartForm.classList.contains('active')) {
        cartForm.style.visibility = 'hidden';
        setTimeout(function() {
            cartForm.style.visibility = 'visible';
        }, 200);
    }

    hideOrderBumpProducts();
    setupQuantityMonitoring();

    const { targetElement, insertMethod } = getOrderBumpInsertTarget();

    if (targetElement) {
        window.cartConfig.orderBumps.forEach((bumpConfig, index) => {
            if (!bumpConfig.enabled) return;
            
            // ‚úÖ Process config first
            const processedConfig = processBumpConfig(bumpConfig);
            if (!processedConfig) {
                console.error(`Order bump ${index} skipped due to invalid config`);
                return;
            }
            
            // ‚úÖ Generate HTML variables
            const titleHTML = replacePlaceholders(processedConfig.title, processedConfig);
            const descriptionHTML = replacePlaceholders(processedConfig.description, processedConfig);
            const bumpId = `order-bump-${index}`;
            
            const orderBumpHTML = `
                <div class="order-bump-container" data-bump-index="${index}">
                    <div class="order-bump-badge">
                        <i class="fa ${processedConfig.badgeIcon}"></i> ${processedConfig.badgeText}
                    </div>
                    <div class="order-bump-content">
                        <label class="order-bump-checkbox">
                            <input type="checkbox" id="${bumpId}-checkbox" class="order-bump-input" value="1" data-bump-index="${index}">
                            <span class="checkmark"></span>
                            <div class="order-bump-text">
                                <div class="order-bump-title">${titleHTML}</div>
                                <div class="order-bump-description">${descriptionHTML}</div>
                            </div>
                        </label>
                        <div class="order-bump-quantity-wrapper" id="${bumpId}-quantity-wrapper" style="display: none;">
                            <div class="bump-quantity-left">
                                <div class="quantity-label">${processedConfig.quantityLabel}</div>
                                <div class="quantity-selector">
                                    <button type="button" class="qty-btn qty-minus" data-bump-index="${index}">
                                        <i class="fa fa-minus"></i>
                                    </button>
                                    <input type="number" class="qty-input" id="${bumpId}-qty-input" value="${processedConfig.defaultQuantity}" min="${processedConfig.minQuantity}" max="${processedConfig.maxQuantity}" readonly data-bump-index="${index}">
                                    <button type="button" class="qty-btn qty-plus" data-bump-index="${index}">
                                        <i class="fa fa-plus"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="quantity-total">
                                <span class="bump-total-price" id="${bumpId}-total-price">${formatPrice(processedConfig.discountedPrice)}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            targetElement.insertAdjacentHTML(insertMethod, orderBumpHTML);
        });
        
        setTimeout(() => {
            setupOrderBumpListeners();
            updateAllBumpVisibility();
        }, 500);
        
        if (window.cartConfig.debugMode) {
            console.log('üéÅ Order Bumps loaded:', window.cartConfig.orderBumps.filter(b => b.enabled).length, 'active');
        }
    }
});

})();
